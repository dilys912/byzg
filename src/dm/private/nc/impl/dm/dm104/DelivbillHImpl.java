/*******************************************************************************
 * *************************************************************\ The skeleton
 * of this class is generated by an automatic * code generator for NC product. * \
 ******************************************************************************/

package nc.impl.dm.dm104;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Vector;

import nc.bs.dm.dm104.DelivbillHDMO;
import nc.bs.dm.pub.DmDMO;
import nc.bs.dm.pub.Transaction;
import nc.bs.dm.pub.toic.DLATP;
import nc.bs.dm.service.so.DelivbillForSO;
import nc.bs.framework.common.NCLocator;
import nc.bs.ml.NCLangResOnserver;
import nc.bs.pub.formulaparse.FormulaParse;
import nc.bs.scm.pub.smart.SmartDMO;

import nc.impl.dm.dm102.DeliverydailyplanImpl;
import nc.impl.dm.pub.DmImpl;
import nc.itf.dm.dm104.IDelivbill;
import nc.itf.dm.dm104.IDelivbillQuery;
import nc.itf.scm.cenpur.service.ChgDataUtil;
import nc.itf.scm.pub.bill.IScm;
import nc.itf.uap.bd.refcheck.IReferenceCheck;

import nc.vo.dm.dm004.ConstForBasePrice;
import nc.vo.dm.dm104.DelivBillVOTool;
import nc.vo.dm.dm104.DelivConvertToOutHItemVO;
import nc.vo.dm.dm104.DelivConvertToOutHVO;
import nc.vo.dm.dm104.DelivbillHHeaderVO;
import nc.vo.dm.dm104.DelivbillHItemVO;
import nc.vo.dm.dm104.DelivbillHVO;
import nc.vo.dm.dm104.OutbillHItemVO;
import nc.vo.dm.dm104.OutbillHVO;
import nc.vo.dm.dm104.ValueRangeHashtableDelivPackNum;
import nc.vo.dm.dm104.ValueRangeHashtableDelivbillBody;
import nc.vo.dm.dm104.ValueRangeHashtableDelivbillHeader;
import nc.vo.dm.dm107.ConstAllotRule;
import nc.vo.dm.dm107.DelivfeebillHItemVO;
import nc.vo.dm.dm107.DelivfeebillHVO;
import nc.vo.dm.pub.CodeNameValue;
import nc.vo.dm.pub.DMBillTypeConst;
import nc.vo.dm.pub.DMDataVO;
import nc.vo.dm.pub.DMOCheckTsStatus;
import nc.vo.dm.pub.DMVO;
import nc.vo.dm.pub.DelivBillStatus;
import nc.vo.dm.pub.ExceptionUtils;
import nc.vo.dm.pub.ValueRange;
import nc.vo.dm.pub.tools.StringTools;
import nc.vo.ic.pub.InvOnHandVO;
import nc.vo.ic.pub.bill.GeneralBillVO;
import nc.vo.pub.AggregatedValueObject;
import nc.vo.pub.BusinessException;
import nc.vo.pub.CircularlyAccessibleValueObject;
import nc.vo.pub.VOStatus;
import nc.vo.pub.billcodemanage.BillCodeObjValueVO;
import nc.vo.pub.lang.UFBoolean;
import nc.vo.pub.lang.UFDateTime;
import nc.vo.pub.lang.UFDouble;
import nc.vo.scm.cenpur.service.ChgDocPkVO;
import nc.vo.scm.pub.SCMEnv;
import nc.vo.scm.pub.SortType;
import nc.vo.scm.pub.session.ClientLink;
import nc.vo.scm.pub.smart.SmartVO;
import nc.vo.scm.recordtime.RecordType;

/**
 * DelivbillH的BO类 创建日期：(2002-6-3)
 * 
 * @author：左小军
 */
public class DelivbillHImpl extends nc.impl.dm.pub.DmImpl implements
    IDelivbillQuery, IDelivbill {
  /**
   * DelivbillHBO 构造子注解。
   */
  public DelivbillHImpl() {
    super();
  }

  /**
   * 根据where子句查询单据。 // 收货方参照发运单做途损单的条件： // (1)收货公司为登陆公司； //
   * (2)对于来源于公司间入库调拨订单,且在途归属为收货方。 // 发货方参照发运单做途损单的条件： //
   * （1）对于来源于公司间入库调拨订单；且在途归属为发货方。 // （2）对于来源于销售订单和直运类型的调拨订单只支持发货方途损。 //
   * 在途归属：从调拨关系表中取。在途归属为收货方，则系统为收货方途损 //公司间调拨订单 5D //组织间调拨订单 5E //组织内调拨订单 5I
   * //总部结算的公司调拨定单 5C
   */
  public DelivbillHVO[] findDelivBillsForWayLoss(String pkdo, String headWhere,
      String itemWhere, boolean isForSendSide, ClientLink clientLink)
      throws BusinessException {
    nc.itf.scm.to.service.IOuter to = null;
    try {
      to = getTOInter();
      if (to == null) {
        throw new BusinessException(new Exception(
            "Error in creating interface ITOOuterDMO."));
      }
    }
    catch (Exception e) {
      throw new BusinessException(new Exception(
          "Error in creating interface ITOOuterDMO."));
    }

    itemWhere = itemWhere + " and isnull(dm_delivbill_b.doutnum, 0)>0 ";

    // getOwnerShipSQL
    // String sBillbPKField ----- 调拨订单子表ID在主查询表（发运表）中对应的字段名
    // int iOwnerShip ----- 要查询的在途归属 0：调出方 1：调入方
    try {
      if (isForSendSide) {// 发货方途损
        itemWhere = itemWhere + " and ( dm_delivbill_b.vbilltype<>'5D'  or "
            + "dm_delivbill_b.vbilltype='5D' and exists ("
            + to.getOwnerShipSQL("dm_delivbill_b.pkorderrow", new Integer(0))
            + ") ) ";
      }
      else {// 收货方途损
        itemWhere = itemWhere + " and dm_delivbill_b.vbilltype='5D' and  "
            + "dm_delivbill_b.pkarrivecorp='" + clientLink.getCorp()
            + "' and exists ("
            + to.getOwnerShipSQL("dm_delivbill_b.pkorderrow", new Integer(1))
            + ") ";
      }
    }
    catch (BusinessException e) {// 防止重复包装的关键处理
      throw e;
    }
    catch (Exception e) {
      reportException(e);
      throw new BusinessException(e);
    }

    // 如果是收货方途损，则需要过滤掉发运组织
    return findDelivBills(isForSendSide ? pkdo : null, headWhere, itemWhere);
  }

  /**
   * 里程。 创建日期：(2001-8-15 10:08:13)
   */
  public String[] getVendorMangID(String pk_cubasdoc) throws BusinessException {
    String s[] = null;
    try {
      DelivbillHDMO dmo = new DelivbillHDMO();
      s = dmo.getVendorMangID(pk_cubasdoc);

    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    return s;
  }

  public DelivbillHHeaderVO findHeaderFieldsValue(String where)
      throws BusinessException {

    DelivbillHHeaderVO delivbillHHeaderVO = null;
    try {
      DelivbillHDMO dmo = new DelivbillHDMO();
      delivbillHHeaderVO = dmo.findHeaderFieldsValue(where);
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    return delivbillHHeaderVO;
  }

  /**
   * 通过主键获得VO对象。 创建日期：(2002-6-3)
   * 
   * @return nc.vo.dm.dm104.DelivbillHVO
   * @param key
   *          String
   * @exception BusinessException
   *              异常说明。
   */
  public DelivbillHVO delivbill_findByPrimaryKey(String key)
      throws BusinessException {

    DelivbillHVO delivbillH = null;
    try {
      DelivbillHDMO dmo = new DelivbillHDMO();
      delivbillH = dmo.findByPrimaryKey(key);
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    return delivbillH;
  }

  /**
   * 根据主键在数据库中删除一个VO对象。 创建日期：(2002-6-3)
   * 
   * @param key
   *          String
   * @exception BusinessException
   *              异常说明。
   */
  public void deleteDelivbill(DelivbillHVO vo, ClientLink clientLink)
      throws BusinessException {
    String sLockPk[] = null;
    String sUserID = null;

    try {
      // 判断删除的是否是整张发运单。
      // 如果传入的 vo 并不包含该所有的表体行，则不允许删除。
      String sBodyPks = null;
      DelivbillHItemVO[] items = (DelivbillHItemVO[]) vo.getChildrenVO();
      for (int i = 0; i < items.length; i++) {
        if (i != 0)
          sBodyPks = sBodyPks + ",'" + (String) items[i].getPk_delivbill_b()
              + "'";
        else
          sBodyPks = "'" + (String) items[i].getPk_delivbill_b() + "'";
      }
      StringBuffer sb = new StringBuffer();
      sb.append("select dr from dm_delivbill_b  ").append(
          "where dr=0 and pk_delivbill_h='"
              + (String) ((DelivbillHHeaderVO) vo.getParentVO())
                  .getPk_delivbill_h() + "' and ").append(
          "pk_delivbill_b not in (" + sBodyPks + ")");
      DMDataVO[] remainderBody = super.query(sb);
      if (remainderBody != null && remainderBody.length > 0) {
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance()
            .getStrByID("40140408", "UPP40140408-000194")/*
                                                           * @res
                                                           * "请确认该发运单所有的表体行都已经查询出来，再进行删除操作！"
                                                           */);
      }

      DelivbillHDMO dmo = new DelivbillHDMO();
      // 加锁
      sLockPk = dmo.getLockPKsArray(vo, "pk_delivbill_h", "pk_delivbill_b",
          "pk_delivbill_h", new String[] {
            "pkdayplan"
          }, new String[0]);

      sUserID = clientLink.getUser();

      lockPKs(sLockPk, sUserID);

      // 删除相应运费单
      deleteTransFeeBillVO(vo);

      // 调用校验方法
      saveCheck(vo, clientLink);

      // 对删除和修改行释放单据号
      returnBillCode("curbilltype", "pkcorpforgenoid", "vdelivbillcode",
          "voldDelivbillcode", new DelivbillHVO[] {
            vo
          });

      // 删除方案
      dmo.dataStoreSave("dm_delivbill_h", "dm_delivbill_b", vo,
          "pk_delivbill_h", "pk_delivbill_b", "pk_delivbill_h",
          "pkcorpforgenoid");
      // 可用量接口
      //采购订单生成的发运单不需要修改可用量
      DLATP dmatp = null;
      if(items[0].getVbilltype() != null
  			&& !"21".equals(items[0].getVbilltype()))
      {
    	  dmatp = new DLATP();
          dmatp.modifyATPWhenDeleteBill(vo);
      }

      dmo.delete(vo, clientLink);

      // 进行按钮注册，删除作为保存的逆操作进行
      signButtonClickTime(RecordType.SAVESEND, vo, true);

      // nc.bs.dm.dm102.Deliverydailyplan remote = null;
      // try {
      // 回写发运日计划
      // nc.bs.dm.dm102.DeliverydailyplanHome home =
      // (nc.bs.dm.dm102.DeliverydailyplanHome)
      // getBeanHome(nc.bs.dm.dm102.DeliverydailyplanHome.class,
      // "nc.bs.dm.dm102.DeliverydailyplanBO");
      // remote = home.create();

      items = (DelivbillHItemVO[]) vo.getChildrenVO();
      DMDataVO[] writeBackItems = new DMDataVO[items.length];
      // 组织接口需要传入的DMDataVO数组
      // "pkbillh","pkbillb","ndelivernum","vbilltype","pk_delivdaypl"
      for (int i = 0; i < items.length; i++) {
        writeBackItems[i] = new DMDataVO();

        // writeBackItems[i].setStatus(nc.vo.pub.VOStatus.UPDATED);
        writeBackItems[i].setStatus(nc.vo.pub.VOStatus.DELETED);

        writeBackItems[i].setAttributeValue("pkbillh", items[i].getPkorder());
        writeBackItems[i]
            .setAttributeValue("pkbillb", items[i].getPkorderrow());

        writeBackItems[i].setAttributeValue("pksalecorp", items[i]
            .getAttributeValue("pksalecorp"));
        writeBackItems[i].setAttributeValue("pksendstockorg", items[i]
            .getAttributeValue("pksendstockorg"));
        writeBackItems[i].setAttributeValue("pkinv", items[i]
            .getAttributeValue("pkinv"));

        //
        UFDouble d = items[i].getDinvnum();
        if (d != null) {
          d = new UFDouble(-1.0 * d.doubleValue());
          writeBackItems[i].setAttributeValue("ndelivernum", d);
        }
        //
        writeBackItems[i].setAttributeValue("vbilltype", items[i]
            .getAttributeValue("vbilltype"));
        writeBackItems[i].setAttributeValue("pk_delivdaypl", items[i]
            .getPkdayplan());
        writeBackItems[i].setAttributeValue("delivstatus", new Integer(items[i]
            .getStatus()));
        writeBackItems[i].setAttributeValue("userid", sUserID);

        // 辅计量和自由项
        writeBackItems[i].setAttributeValue("pkassistmeasure", items[i]
            .getAttributeValue("pkassistmeasure"));
        for (int w = 1; w <= 10; w++) {
          writeBackItems[i].setAttributeValue("vfree" + w, items[i]
              .getAttributeValue("vfree" + w));
        }

        DelivbillHHeaderVO header = (DelivbillHHeaderVO) vo.getParentVO();
        if (header != null) {
          writeBackItems[i].setAttributeValue("pkparamcorp", header
              .getAttributeValue("pkcorpforgenoid"));
          writeBackItems[i].setAttributeValue("snddate", header
              .getAttributeValue("senddate"));
        }
        writeBackItems[i].setAttributeValue("pk_delivbill_h", header
            .getPk_delivbill_h());

        // 如下为与采购相关的一些参数
        // 发运新数量;
        // 发运旧数量,不需要传递
        writeBackItems[i].setAttributeValue("ddelivernewnum", items[i]
            .getDinvnum());

        // @see nc.vo.dm.dm102.DMDelivdayplVOTool.getDelivWritePOData(DMDataVO
        // [])
        // 发货公司
        writeBackItems[i].setAttributeValue("pksalecorp", items[i]
            .getPksalecorp());
        // 到货公司
        writeBackItems[i].setAttributeValue("pkarrivecorp", items[i]
            .getPkarrivecorp());

        writeBackItems[i].setAttributeValue("borderreturn", items[i]
            .getAttributeValue("borderreturn"));// 是否退货
        writeBackItems[i].setAttributeValue("pkorderplanid", items[i]
            .getAttributeValue("pkorderplanid"));// 到货计划
      }
      if (writeBackItems != null) {
        nc.impl.dm.dm102.DeliverydailyplanImpl remote = new nc.impl.dm.dm102.DeliverydailyplanImpl();
        remote.setSendNum(writeBackItems);
      }
      // v5增加：可用量即时校验
      if(dmatp != null)
      {
    	  dmatp.checkAtpInstantly(vo, null);
      }
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    finally {
      try {
        // 解锁
        unLockPKs(sLockPk, sUserID);
      }
      catch (Exception e) {
        reportException(e);
        if (e instanceof BusinessException)
          throw (BusinessException) e;
        else
          throw new BusinessException(e);
      }
    }
  }

  /**
   * 此处插入方法说明。 功能：自动终结发运单 参数： 返回： 例外： 日期：(2002-10-3 18:34:35)
   * 修改日期，修改人，修改原因，注释标志：
   * 
   * @param sBillHeaderPK
   *          java.lang.String
   */
  protected void autoEndBillByPara(String sBillHeaderPK, String sCorpPK,
      ClientLink clientLink) throws BusinessException {
    try {
      String sDM002 = getStringICPara(sCorpPK, "DM002");
      if (sDM002.equals("N")) {
        return;
      }

      boolean bNeedEnd = true;
      DelivbillHVO dhvo = delivbill_findByPrimaryKey(sBillHeaderPK);
      for (int i = 0; i < dhvo.getChildrenVO().length; i++) {
        if (null != dhvo.getChildrenVO()[i].getAttributeValue("vsignname")
            && dhvo.getChildrenVO()[i].getAttributeValue("vsignname")
                .toString().trim().length() != 0) {
          dhvo.getChildrenVO()[i].setAttributeValue("irowstatus", new Integer(
              DelivBillStatus.End));
          dhvo.getChildrenVO()[i].setStatus(nc.vo.pub.VOStatus.UPDATED);
        }
        else {
          bNeedEnd = false;
        }
      }

      // 执行终结
      if (bNeedEnd) {
        DelivbillHDMO dmo = new DelivbillHDMO();
        dmo.update(dhvo, false, clientLink);
      }

    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * 此处插入方法说明。 功能：计算运费 参数： 返回： 例外： 日期：(2002-8-30 20:05:00) 修改日期，修改人，修改原因，注释标志：
   * 
   * @return nc.vo.dm.pub.DMDataVO
   * @param dmdvoForCalculate
   *          nc.vo.dm.pub.DMDataVO
   * @exception BusinessException
   *              异常说明。
   */
  public nc.vo.dm.pub.DMDataVO calculateTransFee(
      nc.vo.dm.pub.DMDataVO dmdvoFeeItems) throws BusinessException {
    try {

      // 查询费用构成项属性
      DMDataVO dmdvoFeeConItemsAll = queryForitem("");

      // 临时建立费用项结果表,用于后继计算
      Hashtable htForFeeItemValue = new Hashtable();
      // 临时建立函数取值的费用构成项结果表,用于后继计算
      Hashtable htForFeeConItemValue = new Hashtable();
      // 临时建立函数取数组值的费用构成项结果表,用于后继计算
      Hashtable htForFeeConItemArrayValue = new Hashtable();

      // 建立公式
      FormulaParse fparse = new FormulaParse();

      // 发运单VO
      DMVO dmvoTransBillVO = (DMVO) dmdvoFeeItems
          .getAttributeValue("transbill");

      // 费用项vo
      DMDataVO dmdvoCodeToFee = (DMDataVO) dmvoTransBillVO.getParentVO()
          .getAttributeValue("codetofeevos");

      // 金额精度
      Integer BD301 = (Integer) dmvoTransBillVO.getParentVO()
          .getAttributeValue("BD301");

      CodeNameValue cnv = null;

      String[] sFeeItemNames = dmdvoFeeItems.getAttributeNames();
      int iGroupofFeeItem = sFeeItemNames.length - 2;
      if (iGroupofFeeItem > 0) {
        for (int i = 0; i < iGroupofFeeItem + 2; i++) {
          // 此费用项是否需要手拆到行标志
          boolean bIsnotNeedHandSplit = true;
          // 依次计算费用项及费用构成项
          // /跳过VO和总公式
          if (sFeeItemNames[i].equals("allform")
              || sFeeItemNames[i].equals("transbill")
              || sFeeItemNames[i].equals("packagebill"))
            continue;

          // 取出费用项
          DMDataVO dmdvosFeeItem = (DMDataVO) dmdvoCodeToFee
              .getAttributeValue(sFeeItemNames[i]);
          // 取出费用构成项
          DMDataVO dmdvoFeeConItems = (DMDataVO) dmdvoFeeItems
              .getAttributeValue(sFeeItemNames[i]);
          // 将费用项信息置入发运单用于其他费用构成项取数函数的计算
          dmvoTransBillVO.getParentVO().setAttributeValue("feevo",
              dmdvosFeeItem);

          // 其他费用项取数函数在同一费用项中算过一次就不用再算
          HashMap hmFeeToFeeItem = new HashMap();

          String[] sFeeConItemNames = dmdvoFeeConItems.getAttributeNames();
          int iGroupofFeeConItem = sFeeConItemNames.length - 1; // 对应此费用项的费用构成项的个数
          if (iGroupofFeeConItem >= 0) {
            // 取得是否要手拆的属性
            for (int j = 0; j < iGroupofFeeConItem + 1; j++) {
              // 依次判断费用构成项
              // /跳过总公式
              if (sFeeConItemNames[j].equals("allform"))
                continue;

              // 判断费用构成项的属性
              DMDataVO dmdvoFeeConItemAttrib = (DMDataVO) dmdvoFeeConItemsAll
                  .getAttributeValue(sFeeConItemNames[j]);
              String sFunClass = dmdvoFeeConItemAttrib.getAttributeValue(
                  "ifhandsplit").toString();
              if (sFunClass.equals("1")) {
                bIsnotNeedHandSplit = false;
                break;
              }
            }
            for (int j = 0; j < iGroupofFeeConItem + 1; j++) {
              // 依次计算费用构成项
              // /跳过总公式
              if (sFeeConItemNames[j].equals("allform"))
                continue;

              // 准备置入费用构成项值
              cnv = ((CodeNameValue) dmdvoFeeConItems
                  .getAttributeValue(sFeeConItemNames[j]));

              // 计算费用构成项值
              // 判断费用构成项的属性
              DMDataVO dmdvoFeeConItemAttrib = (DMDataVO) dmdvoFeeConItemsAll
                  .getAttributeValue(sFeeConItemNames[j]);
              String sFunClass = dmdvoFeeConItemAttrib.getAttributeValue(
                  "vgetfunclass").toString();
              // 对手填型不做计算
              if (sFunClass.equals("手填方式") || sFunClass.equals("下拉方式")) {/*-=notranslate=-*/
                UFDouble[] ufdForRow = new UFDouble[dmvoTransBillVO
                    .getBodyVOs().length];
                String[] sForRow = new String[dmvoTransBillVO.getBodyVOs().length];
                htForFeeConItemValue.put(sFeeConItemNames[j], cnv.Value
                    .toString());
                for (int w = 0; w < ufdForRow.length; w++) {
                  ufdForRow[w] = new UFDouble(cnv.Value.toString());
                  sForRow[w] = cnv.Value.toString();
                }
                // htForFeeConItemArrayValue.put(sFeeConItemNames[j],
                // ufdForRow);
                htForFeeConItemArrayValue.put(sFeeConItemNames[j], sForRow);
                continue;
              }
              else {
                UFDouble[] ufdForRow = new UFDouble[dmvoTransBillVO
                    .getBodyVOs().length];
                String[] sForRow = new String[dmvoTransBillVO.getBodyVOs().length];
                Object ufdFeeConItemValueNow = new UFDouble(0);
                if ((bIsnotNeedHandSplit
                    && htForFeeConItemArrayValue
                        .containsKey(sFeeConItemNames[j]) && (sFeeItemNames[i]
                    .startsWith("PRICE") && hmFeeToFeeItem
                    .containsKey(sFeeItemNames[i])))
                    || (!bIsnotNeedHandSplit
                        && htForFeeConItemValue
                            .containsKey(sFeeConItemNames[j]) && (sFeeItemNames[i]
                        .startsWith("PRICE") && hmFeeToFeeItem
                        .containsKey(sFeeItemNames[i])))) {
                  // 已查过该费用构成项
                }
                else {
                  String sClassMethod = dmdvoFeeConItemAttrib
                      .getAttributeValue("vgetfunction").toString();
                  // 计算费用构成项值
                  // ufdForRow= new
                  // UFDouble[dmvoTransBillVO.getBodyVOs().length];
                  // 置入
                  ufdFeeConItemValueNow = getFeeConItemValue(sFunClass,
                      sClassMethod, dmvoTransBillVO, ufdForRow,
                      bIsnotNeedHandSplit);
                  // 置入费用构成项值
                  // if (bIsnotNeedHandSplit)
                  // htForFeeConItemArrayValue.put(sFeeConItemNames[j],
                  // ufdForRow);
                  for (int w = 0; w < ufdForRow.length; w++) {
                    sForRow[w] = (ufdForRow[w] == null ? "0" : ufdForRow[w]
                        .toString());
                  }
                  htForFeeConItemArrayValue.put(sFeeConItemNames[j], sForRow);
                  hmFeeToFeeItem.put(sFeeItemNames[i], "");
                  htForFeeConItemValue.put(sFeeConItemNames[j],
                      ufdFeeConItemValueNow.toString());
                }

                // 保留值
                try {
                  cnv.Value = new UFDouble(htForFeeConItemValue.get(
                      sFeeConItemNames[j]).toString());
                }
                catch (Exception e) {
                  cnv.Value = htForFeeConItemValue.get(sFeeConItemNames[j])
                      .toString();
                  /** <needn't>需要如此实现。zxping 20050617 */
                }

                dmdvoFeeConItems.setAttributeValue(sFeeConItemNames[j], cnv);
              }

            }
            // 准备置入费用项值
            cnv = ((CodeNameValue) dmdvoFeeConItems
                .getAttributeValue("allform"));

            // 计算费用项值
            fparse.setExpress(cnv.Code);
            fparse.setData((Hashtable) htForFeeConItemValue.clone());
            String sValue = fparse.getValue();

            // 置回到cnv中
            cnv.Value = new UFDouble(sValue, -BD301.intValue());
            dmdvoFeeConItems.setAttributeValue("allform", cnv);
            // htForFeeItemValue.put(sFeeItemNames[i], sValue);
            htForFeeItemValue.put(sFeeItemNames[i], cnv.Value.toString());

            // 只有一行时，直接拆分
            if (dmvoTransBillVO.getBodyVOs().length == 1) {
              dmvoTransBillVO.getBodyVOs()[0].setAttributeValue(
                  sFeeItemNames[i], cnv.Value);
            }
            else if (bIsnotNeedHandSplit) { // 当需要自动拆分到行时，执行拆分
              // 计算拆分费用项值
              fparse.setExpress(cnv.Code);
              fparse.setData((Hashtable) htForFeeConItemArrayValue.clone());
              String[] sValueArray = fparse.getValueS();
              // 拆分到发运单行
              // 同时注意拆分时要检查数据合计与费用项的总和是否一致
              UFDouble ufdSumTotal = new UFDouble(0);
              UFDouble ufdRowValue = new UFDouble(0);
              for (int w = 0; w < sValueArray.length; w++) {
                ufdRowValue = new UFDouble(sValueArray[w], -BD301.intValue());
                ufdSumTotal = ufdSumTotal.add(ufdRowValue);
                if (null != sValueArray[w]) {
                  dmvoTransBillVO.getBodyVOs()[w].setAttributeValue(
                      sFeeItemNames[i], ufdRowValue);
                }
              }
              // 如果总和不一致
              if (ufdSumTotal.doubleValue() != new UFDouble(cnv.Value
                  .toString()).doubleValue()) {
                int iMinus = new UFDouble(cnv.Value.toString())
                    .sub(ufdSumTotal).multiply(Math.pow(10, BD301.intValue()))
                    .intValue();
                // 将差值依每行补入
                for (int newrow = 0; newrow < Math.abs(iMinus); newrow++) {
                  if (newrow == sValueArray.length - 1) {
                    // 已到最后一行
                    ufdRowValue = new UFDouble(sValueArray[newrow], -BD301
                        .intValue());
                    ufdRowValue = ufdRowValue.add((Math.abs(iMinus) - newrow)
                        * (iMinus > 0 ? Math.pow(10, -BD301.intValue()) : -Math
                            .pow(10, -BD301.intValue())));
                    dmvoTransBillVO.getBodyVOs()[newrow].setAttributeValue(
                        sFeeItemNames[i], ufdRowValue);
                    break;
                  }
                  else {
                    ufdRowValue = new UFDouble(sValueArray[newrow], -BD301
                        .intValue());
                    ufdRowValue = ufdRowValue.add(iMinus > 0 ? Math.pow(10,
                        -BD301.intValue()) : -Math.pow(10, -BD301.intValue()));
                    dmvoTransBillVO.getBodyVOs()[newrow].setAttributeValue(
                        sFeeItemNames[i], ufdRowValue);
                  }
                }
              }
            }
            else if (!bIsnotNeedHandSplit) { // 直接拆分到第一行
              dmvoTransBillVO.getBodyVOs()[0].setAttributeValue(
                  sFeeItemNames[i], cnv.Value);
              for (int s = 1; s < dmvoTransBillVO.getBodyVOs().length; s++) {
                dmvoTransBillVO.getBodyVOs()[s].setAttributeValue(
                    sFeeItemNames[i], new UFDouble(0));
              }
            }
          }

        }
        // 计算总公式值
        cnv = ((CodeNameValue) dmdvoFeeItems.getAttributeValue("allform"));
        fparse.setExpress(cnv.Code);
        fparse.setData((Hashtable) htForFeeItemValue.clone());
        String sValue = fparse.getValue();

        // 置回到cnv中
        cnv.Value = new UFDouble(sValue, -BD301.intValue());
        dmdvoFeeItems.setAttributeValue("allform", cnv);
      }

    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    return dmdvoFeeItems;
  }

  /**
   * @author 仲瑞庆 函数的功能、用途、对属性的更改，以及函数执行前后对象的状态。 弃审
   * @param 参数说明
   * @return 返回值
   * @exception 异常描述
   * @see 需要参见的其它内容
   * @since 从类的那一个版本，此方法被添加进来。（可选） (2002-10-24 15:49:01)
   * @return java.util.ArrayList
   * @param delivbillH
   *          nc.vo.dm.dm104.DelivbillHVO
   * @param dmitems
   *          nc.vo.dm.pub.DMDataVO[]
   * @exception BusinessException
   *              异常说明。
   */
  public ArrayList cancelAuditDelivbill(DelivbillHVO delivbillH,
      ClientLink clientLink) throws BusinessException {
    // 检查下游单据是否存在，只对修改和删除单据检查
    CircularlyAccessibleValueObject[] dmdvos = new CircularlyAccessibleValueObject[1];
    dmdvos[0] = delivbillH.getParentVO();
    super.checkLowerBillExist("pk_delivbill_h", "vdelivbillcode", new String[] {
        "ic_general_b", "dm_missionbill_h", "dm_sign_b", "dm_wayloss_h"
    }, new String[] {
        "csourcebillhid", "pkdelivbill", "pk_sourcebill_h", "pk_delivbill_h"
    }, new String[] {
        "ts", "ts", "ts", "ts"
    }, dmdvos);
    // 更新单据
    // return audit(delivbillH, dmitems, true, clientLink);

    ArrayList resultlist = updateDelivbill(delivbillH, null, false, clientLink);

    // 进行按钮注册
    signButtonClickTime(RecordType.AUDITSEND, delivbillH, true);

    return resultlist;
  }

  /**
   * 正常的签收确认。 创建日期：(2002-6-11)
   * 
   * @param delivbillH
   *          nc.vo.dm.dm106.DelivbillHVO
   * @exception BusinessException
   *              异常说明。
   */
  public ArrayList cancelSignDelivPlan(DelivbillHVO delivbillH,
      DMDataVO[] replandata, DMDataVO[] reOutbillData, ClientLink clientLink)
      throws BusinessException {
    return updateSignDelivPlan(delivbillH, replandata, reOutbillData, true,
        clientLink);
  }

  /**
   * 用VO对象的属性值更新数据库。 创建日期：(2002-6-11)
   * 
   * @param delivbillH
   *          nc.vo.dm.dm106.DelivbillHVO
   * @exception BusinessException
   *              异常说明。
   */
  protected void cancelSignOutBill(DMDataVO[] reOutbillData)
      throws BusinessException {
    // 回写出库单
    try {
      // nc.bs.ic.pub.ictodm.IC2DMInterface dmo= new
      // nc.bs.ic.pub.ictodm.IC2DMInterface();
      // UFBoolean b= dmo.reverseOutSignNum(reOutbillData);
      UFBoolean b = getICInter().reverseOutSignNum(reOutbillData);
      if (!b.booleanValue()) {
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance()
            .getStrByID("40140408", "UPP40140408-000113")/* @res "出库单未能完成取消签收！" */);
      }
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * 作者：毕晖 保存Ts检查。 功能： 参数： CircularlyAccessibleValueObject[] 返回： 例外：
   * 日期：(2002-7-24 20:24:01) 修改日期，修改人，修改原因，注释标志：
   */
  protected void checkBodyTs(CircularlyAccessibleValueObject[] vos,
      Hashtable bht) throws BusinessException {
    try {
      String[] sTs = new String[vos.length];
      String[] sPK = new String[vos.length];
      for (int i = 0; i < vos.length; i++) {
        if (vos[i].getStatus() != VOStatus.NEW) {
          sPK[i] = (String) vos[i].getAttributeValue("pk_delivbill_b");
          sTs[i] = (String) vos[i].getAttributeValue("ts");
        }
        else {
          sPK[i] = null;
        }

      }
      DmDMO dmdmo = new DmDMO();
      Hashtable ht = dmdmo.checkRowExitOrChanged(sPK, sTs, "dm_delivbill_b",
          "pk_delivbill_b", "ts");
      int ooo = 0;
      StringBuffer sb = new StringBuffer();
      String sCode = new String();
      Hashtable newHt = new Hashtable();
      Hashtable dlvbillcodeHash = new Hashtable();
      for (int i = 0; i < sPK.length; i++) {
        if (sPK[i] == null)
          continue;
        Integer iCheck = new Integer(ht.get(sPK[i]).toString());
        if (iCheck.intValue() == DMOCheckTsStatus.IsNotTheSameTs) {
          sCode = (String) bht.get(vos[i]);
          if (!ht.containsValue(sCode)) {
            if (ooo != 0) {
              if (dlvbillcodeHash.containsKey(sCode) == false) {
                sb.append(", " + sCode);
                dlvbillcodeHash.put(sCode, "Y");
              }
            }
            else {
              sb.append(sCode);
              dlvbillcodeHash.put(sCode, "Y");
            }
            newHt.put(new Integer(i), sCode);
            ooo++;
          }
        }
      }
      if (sb.toString().trim().length() > 0) {
        String[] value = new String[] {
          sb.toString()
        }; //
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance()
            .getStrByID("40140408", "UPP40140408-000127", null, value)/*
                                                                       * @res
                                                                       * "请重新查询单据号为：{0}
                                                                       * 的记录！"
                                                                       */);
      }
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * 作者：毕晖 保存Ts检查。 功能： 参数： CircularlyAccessibleValueObject[] 返回： 例外：
   * 日期：(2002-7-24 20:24:01) 修改日期，修改人，修改原因，注释标志：
   */
  protected void checkHeadTs(CircularlyAccessibleValueObject[] vos)
      throws BusinessException {
    try {
      String[] sTs = new String[vos.length];
      String[] sPK = new String[vos.length];
      for (int i = 0; i < vos.length; i++) {
        if (vos[i].getStatus() != VOStatus.NEW) {
          sPK[i] = (String) vos[i].getAttributeValue("pk_delivbill_h");
          sTs[i] = (String) vos[i].getAttributeValue("ts");
        }
        else {
          sPK[i] = null;
        }

      }
      DmDMO dmdmo = new DmDMO();
      Hashtable ht = dmdmo.checkRowExitOrChanged(sPK, sTs, "dm_delivbill_h",
          "pk_delivbill_h", "ts");
      int ooo = 0;
      StringBuffer sb = new StringBuffer();
      String sCode = new String();
      for (int i = 0; i < sPK.length; i++) {
        if (sPK[i] == null)
          continue;
        Integer iCheck = new Integer(ht.get(sPK[i]).toString());
        if (iCheck.intValue() == DMOCheckTsStatus.IsNotTheSameTs) {
          sCode = (String) vos[i].getAttributeValue("vdelivbillcode");
          if (ooo != 0) {
            sb.append(", " + sCode);
          }
          else {
            sb.append(sCode);
          }
          ooo++;
        }
      }
      if (sb.toString().trim().length() > 0) {
        String[] value = new String[] {
          sb.toString()
        };//
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance()
            .getStrByID("40140408", "UPP40140408-000127", null, value)/*
                                                                       * @res
                                                                       * "请重新查询单据号为：{0}
                                                                       * 的记录！"
                                                                       */);
      }
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * 作者：毕晖 此处插入方法说明。 功能：Ts检查 参数：AggregatedValueObject[] 返回： 例外： 日期：(2002-7-26
   * 11:34:14) 修改日期，修改人，修改原因，注释标志：
   */
  protected void checkTs(AggregatedValueObject[] vos) throws BusinessException {
    DelivbillHHeaderVO[] headvos = new DelivbillHHeaderVO[vos.length];
    Vector v = new Vector();
    Hashtable ht = new Hashtable();
    String sCode = new String();
    for (int i = 0; i < vos.length; i++) {
      headvos[i] = (DelivbillHHeaderVO) vos[i].getParentVO();
      sCode = (String) headvos[i].getAttributeValue("vdelivbillcode");
      DelivbillHItemVO[] items = (DelivbillHItemVO[]) vos[i].getChildrenVO();
      for (int j = 0; j < items.length; j++) {
        v.addElement(items[j]);
        ht.put(items[j], sCode);
      }
    }
    // HEAD Ts 检查
    checkHeadTs(headvos);

    // BODY Ts 检查
    if (v.size() > 0) {
      DelivbillHItemVO[] newItems = new DelivbillHItemVO[v.size()];
      v.copyInto(newItems);
      checkBodyTs(newItems, ht);
    }
  }

  /**
   * 用VO对象的属性值更新数据库。 创建日期：(2002-6-3)
   * 
   * @param delivbillH
   *          nc.vo.dm.dm104.DelivbillHVO
   * @exception BusinessException
   *              异常说明。
   */
  public ArrayList confirmDelivbill(DelivbillHVO delivbillH,
      DMDataVO[] dmitems, boolean bCancel, ClientLink clientLink)
      throws BusinessException {
    ArrayList resultlist;
    try {
      resultlist = updateDelivbill(delivbillH, dmitems, false, clientLink);

      // 进行按钮注册
      // signButtonClickTime(RecordType.SIGNOUTTRAN, delivbillH, bCancel);

    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }

    return resultlist;
  }

  /**
   * 此处插入方法说明。 功能：删除运费单 参数： 返回： 例外： 日期：(2002-9-4 20:40:39) 修改日期，修改人，修改原因，注释标志：
   * 
   * @param DelivPackNumVO
   *          nc.vo.dm.pub.DMDataVO[]
   * @param TransFeeVO
   *          nc.vo.dm.pub.DMVO
   * @exception BusinessException
   *              异常说明。
   */
  protected void deleteTransFeeBillVO(DelivbillHVO DelivBillVO)
      throws BusinessException {
    // 未考虑加锁
    // DelivfeebillH remote = null;
    try {
      // 取得bean
      // DelivfeebillHHome home =
      // (DelivfeebillHHome) getBeanHome(DelivfeebillHHome.class,
      // "nc.bs.dm.dm107.DelivfeebillHBO");
      // remote = home.create();
      nc.impl.dm.dm107.DelivfeebillHImpl remote = new nc.impl.dm.dm107.DelivfeebillHImpl();

      // 先查以前的运费单
      String sDelivPK = (String) DelivBillVO.getParentVO().getAttributeValue(
          "pk_delivbill_h");
      String sDelifOrgPK = (String) DelivBillVO.getParentVO()
          .getAttributeValue("pkdelivorg");
      String sWhereClause = " dm_delivfeebill_h.pk_delivbill_h='" + sDelivPK
          + "'";
      ArrayList al = remote.delivfeebill_findBillByHid(sWhereClause,
          sDelifOrgPK);

      // 删除以前的运费单
      if (al != null && al.size() > 0) {
        DelivfeebillHVO[] TransFeeVOolds = (DelivfeebillHVO[]) al.get(0);
        if (null != TransFeeVOolds && TransFeeVOolds.length != 0) {
          for (int i = 0; i < TransFeeVOolds.length; i++) {
            // DelivfeebillHVO TransFeeVOold= (DelivfeebillHVO) al.get(i);
            TransFeeVOolds[i].getParentVO().setAttributeValue("userid",
                DelivBillVO.getParentVO().getAttributeValue("userid"));
            remote.deleteWhenEraseDelivBill(TransFeeVOolds[i]);
          }
        }

      }
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * 根据发运单表体行对应自由状态出库单的应发数量汇总来过滤发运单。 该参数是选择出库单的应发数量的计算方法。当参数 DM011 选择“Y”时，
   * 出库单的应发数量的计算方法为： 应发数量＝发运数－累实发－未做实际出库的累应发 eg: 发运数量100 第一次出库单： 发运出库数量：30
   * 出库单实出数量 20 第一次出库单： 发运出库数量：50 出库单实出数量 0当为Y时， 此时，应发数量为 30=（100-20-50）
   * 
   * @return nc.vo.dm.dm104.DelivbillHItemVO[]
   * @param items
   *          nc.vo.dm.dm104.DelivbillHItemVO[]
   */
  private DelivbillHItemVO[] filterDlvitemsForOut(DelivbillHItemVO[] items)
      throws BusinessException {
    try {
      DelivbillHItemVO[] filterItems = null;
      ArrayList filterList = new ArrayList();
      // 修改items将表体数量减去应发数量汇总
      String[] itemPks = new String[items.length];
      for (int i = 0; i < items.length; i++) {
        itemPks[i] = items[i].getPk_delivbill_b();
      }
      nc.bs.dm.pub.fromic.DmFromIcDMO icDmo = new nc.bs.dm.pub.fromic.DmFromIcDMO();
      // DMDataVO[] itemOutnums = icDmo.queryDeliv2OutSumShouldOutNum(itemPks);
      DMDataVO[] itemOutnums = icDmo.queryDeliv2OutSumShouldOutNum2(items[0]
          .getPk_delivbill_h());

      Hashtable itemHash = new Hashtable();
      for (int i = 0; i < itemOutnums.length; i++) {
        itemHash.put(itemOutnums[i].getAttributeValue("pk_delivbill_b"),
            itemOutnums[i].getAttributeValue("sumyf"));
      }
      for (int i = 0; i < items.length; i++) {
        UFDouble ufdSumShould = null;
        if (itemHash.get(itemPks[i]) != null) {
          ufdSumShould = new UFDouble(itemHash.get(itemPks[i]).toString());
        }
        else
          ufdSumShould = new UFDouble(0);

        // the next line is commented by zxping @2005-3-22 15:38 due to it's a
        // fatal bug.
        // items[i].setDsignnum(items[i].getDinvnum());

        UFDouble ufdOutnum = items[i].getDoutnum();
        if (ufdOutnum == null)
          ufdOutnum = new UFDouble(0);
        if (ufdSumShould != null && items[i].getDinvnum() != null) {
          UFDouble ufdInvnum = items[i].getDinvnum().sub(ufdSumShould);
          if ((ufdInvnum.sub(ufdOutnum)).doubleValue() > 0) { //
            items[i].setDinvnum(ufdInvnum);
            filterList.add(items[i]);
          }
          else { // 过滤掉这一行
          }
        }
      } // for (int i = 0; i < items.length; i++)

      if (filterList.size() == 0) {
        throw new Exception(nc.bs.ml.NCLangResOnserver.getInstance()
            .getStrByID("40140408", "UPP40140408-000114")/*
                                                           * @res
                                                           * "没有可以出库的发运单表体行"
                                                           */);
      }

      filterItems = new DelivbillHItemVO[filterList.size()];
      filterItems = (DelivbillHItemVO[]) filterList
          .toArray(new DelivbillHItemVO[0]);
      return filterItems;
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }

  }

  /**
   * 根据发运单表体行对应所有出库单的应发数量汇总来过滤发运单。 当参数 DM011 选择“N”时，出库单的应发数量为： 应发数量＝发运数－累应发。 eg:
   * 发运数量100 第一次出库单： 发运出库数量：30 出库单实出数量 20 第一次出库单： 发运出库数量：50 出库单实出数量 0当为Y时，
   * 此时，应发数量为 20=100-（30+50）
   * 
   * @return nc.vo.dm.dm104.DelivbillHItemVO[]
   * @param items
   *          nc.vo.dm.dm104.DelivbillHItemVO[]
   */
  private DelivbillHItemVO[] filterDlvitemsForOutNoOutNum(
      DelivbillHItemVO[] items) throws BusinessException {
    try {
      DelivbillHItemVO[] filterItems = null;
      ArrayList filterList = new ArrayList();

      // 修改items将表体数量减去应发数量汇总
      String[] itemPks = new String[items.length];
      for (int i = 0; i < items.length; i++) {
        itemPks[i] = items[i].getPk_delivbill_b();
      }
      nc.bs.dm.pub.fromic.DmFromIcDMO icDmo = new nc.bs.dm.pub.fromic.DmFromIcDMO();
      // DMDataVO[] itemOutnums=
      // icDmo.queryDeliv2OutSumShouldOutNumNoOutNum(itemPks);
      DMDataVO[] itemOutnums = icDmo
          .queryDeliv2OutSumShouldOutNumNoOutNum2(items[0].getPk_delivbill_h());

      Hashtable itemHash = new Hashtable();
      for (int i = 0; i < itemOutnums.length; i++) {
        itemHash.put(itemOutnums[i].getAttributeValue("pk_delivbill_b"),
            itemOutnums[i].getAttributeValue("sumyf"));
      }
      for (int i = 0; i < items.length; i++) {
        UFDouble ufdSumShould = null;
        if (itemHash.get(itemPks[i]) != null) {
          ufdSumShould = new UFDouble(itemHash.get(itemPks[i]).toString());
        }
        else
          ufdSumShould = new UFDouble(0);
        // UFDouble ufdOutnum = items[i].getDoutnum();
        // if (ufdOutnum == null)
        // ufdOutnum = new UFDouble(0);
        items[i].setDsignnum(items[i].getDinvnum());
        if (ufdSumShould != null && items[i].getDinvnum() != null) {
          UFDouble ufdInvnum = items[i].getDinvnum().sub(ufdSumShould);
          if (ufdInvnum.doubleValue() > 0) { //
            items[i].setDinvnum(ufdInvnum);
            items[i].setDoutnum(null);
            filterList.add(items[i]);
          }
          else { // 过滤掉这一行
          }
        }
      } // for (int i = 0; i < items.length; i++)

      if (filterList.size() == 0) {
        throw new Exception(nc.bs.ml.NCLangResOnserver.getInstance()
            .getStrByID("40140408", "UPP40140408-000114")/*
                                                           * @res
                                                           * "没有可以出库的发运单表体行"
                                                           */);
      }

      filterItems = new DelivbillHItemVO[filterList.size()];
      filterItems = (DelivbillHItemVO[]) filterList
          .toArray(new DelivbillHItemVO[0]);
      return filterItems;
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }

  }

  /**
   * 根据where子句查询单据。 功能： 参数： 返回： 例外： 日期：(2002-9-9 22:34:22) 修改日期，修改人，修改原因，注释标志：
   * 
   * @return nc.vo.dm.dm104.DelivbillHVO[]
   * @param currentdoname
   *          java.lang.String
   * @param pkdo
   *          java.lang.String
   * @param headWhere
   *          java.lang.String
   * @param itemWhere
   *          java.lang.String
   */
  public DelivbillHVO[] findDelivBills(String pkdo, String headWhere,
      String itemWhere) throws BusinessException {
    return findDelivBills(pkdo, headWhere, itemWhere, new UFBoolean(false));
  }

  /**
   * 根据where子句查询单据。 功能： 参数： 返回： 例外： 日期：(2002-9-9 22:34:22) 修改日期，修改人，修改原因，注释标志：
   * 
   * @return nc.vo.dm.dm104.DelivbillHVO[]
   * @param currentdoname
   *          java.lang.String
   * @param pkdo
   *          java.lang.String
   * @param headWhere
   *          java.lang.String
   * @param itemWhere
   *          java.lang.String
   */
  public DelivbillHVO[] findDelivBills(String pkdo, String headWhere,
      String itemWhere, UFBoolean ufbIsForSoFee) throws BusinessException {
    DelivbillHVO[] bills = null;
    DelivbillHVO onebill = null;
    DelivbillHHeaderVO[] headers = null;
    DelivbillHItemVO[] allItems = null;
    String[] keys = null;
    Vector billVector = new Vector();
    try {
      // 测试效率用
      long start = getCurrentTime();
      //
      DelivbillHDMO dmo = new DelivbillHDMO();
      // 找到所有表头
      headers = dmo.findallHeaderByWhere(pkdo, headWhere);
      if (headers == null || headers.length == 0)
        return null;

      bills = new DelivbillHVO[headers.length];
      // 找到所有表头主键,找出所有表体
      keys = new String[headers.length];
      for (int i = 0; i < headers.length; i++) {
        keys[i] = headers[i].getPrimaryKey();
      }

      allItems = dmo.findItemsForMutiHeader(pkdo, headWhere, itemWhere,
          ufbIsForSoFee);

      Hashtable allItemHash = new Hashtable();
      Vector onebillitemsList = null;
      String oneItemKey = null;
      for (int i = 0; i < allItems.length; i++) {
        oneItemKey = allItems[i].getPk_delivbill_h();
        if (allItemHash.containsKey(oneItemKey)) {
          onebillitemsList = (Vector) allItemHash.get(oneItemKey);
          onebillitemsList.add(allItems[i]);
        }
        else {
          onebillitemsList = new Vector();
          onebillitemsList.add(allItems[i]);
          allItemHash.put(oneItemKey, onebillitemsList);
        }
      }
      //
      // 逐个表头找到表体
      DelivbillHItemVO[] onebillitems = null;
      for (int i = 0; i < headers.length; i++) {
        if (allItemHash.containsKey(keys[i])) {
          onebill = new DelivbillHVO();
          onebillitemsList = (Vector) allItemHash.get(keys[i]);
          onebillitems = new DelivbillHItemVO[onebillitemsList.size()];
          onebillitemsList.copyInto(onebillitems);

          if (onebillitems != null && onebillitems.length != 0) {
            onebill.setChildrenVO(onebillitems);
            // 如果表体非空将单据加入vector
            onebill.setParentVO(headers[i]);
            billVector.add(onebill);
          }
        }
      }

      // 由vector转换为单据数组
      bills = new DelivbillHVO[billVector.size()];
      billVector.copyInto(bills);
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    return bills;
  }

  /**
   * 根据where子句查询单据。 功能： 参数： 返回： 例外： 日期：(2002-9-9 22:34:22) 修改日期，修改人，修改原因，注释标志：
   * 
   * @return nc.vo.dm.dm104.DelivbillHVO[]
   * @param currentdoname
   *          java.lang.String
   * @param pkdo
   *          java.lang.String
   * @param headWhere
   *          java.lang.String
   * @param itemWhere
   *          java.lang.String
   */
  public DelivbillHVO[] findDelivBillsForSign(String pkdo, String headWhere,
      String itemWhere, DMDataVO dmdvoSendStororg) throws BusinessException {
    DelivbillHVO[] bills = null;
    DelivbillHVO onebill = null;
    DelivbillHHeaderVO[] headers = null;
    DelivbillHItemVO[] allItems = null;
    String[] keys = null;
    Vector billVector = new Vector();
    try {
      // 测试效率用
      long start = getCurrentTime();
      //
      DelivbillHDMO dmo = new DelivbillHDMO();
      // 找到所有表头
      headers = dmo.findallHeaderByWhere(pkdo, headWhere);

      bills = new DelivbillHVO[headers.length];
      // 找到所有表头主键,找出所有表体
      keys = new String[headers.length];
      for (int i = 0; i < headers.length; i++) {
        keys[i] = headers[i].getPrimaryKey();
      }
      if(dmdvoSendStororg.getAttributeValue("agentcorpids")!=null){
      String[] AgentCorpID = (String[]) ((ArrayList) dmdvoSendStororg.getAttributeValue("agentcorpids")).toArray(new String[0]);
      nc.impl.dm.dm102.DeliverydailyplanImpl dataPowerBO = new nc.impl.dm.dm102.DeliverydailyplanImpl();
      String itemsSql = dataPowerBO
      .deliverydailyplan_getDataPowerSubSql(
          "bd_calbody",
          "库存组织",
          //"dm_delivbill_b.pksendstockorg",
          "(case when dm_delivbill_b.vbilltype='21' and dm_delivbill_b.borderreturn='N' then dm_delivbill_b.pkdeststockorg else  dm_delivbill_b.pksendstockorg end) ",
          AgentCorpID, dmdvoSendStororg.getAttributeValue("userid").toString());
      }
      allItems = dmo.findItemsForMutiHeader(pkdo, headWhere, itemWhere);

      Hashtable allItemHash = new Hashtable();
      Vector onebillitemsList = null;
      String oneItemKey = null;
      for (int i = 0; i < allItems.length; i++) {
        oneItemKey = allItems[i].getPk_delivbill_h();
        if (allItemHash.containsKey(oneItemKey) == true) {
          onebillitemsList = (Vector) allItemHash.get(oneItemKey);
          onebillitemsList.add(allItems[i]);
        }
        else {
          onebillitemsList = new Vector();
          onebillitemsList.add(allItems[i]);
          allItemHash.put(oneItemKey, onebillitemsList);
        }
      }
      //
      // 逐个表头找到表体
      DelivbillHItemVO[] onebillitems = null;
      for (int i = 0; i < headers.length; i++) {
        if (allItemHash.containsKey(keys[i])) {
          onebill = new DelivbillHVO();
          onebillitemsList = (Vector) allItemHash.get(keys[i]);
          onebillitems = new DelivbillHItemVO[onebillitemsList.size()];
          onebillitemsList.copyInto(onebillitems);
          // if (onebill.getChildrenVO() != null &&
          // onebill.getChildrenVO().length != 0) {
          if (onebillitems != null && onebillitems.length != 0) {
            onebill.setChildrenVO(onebillitems);
            // 如果表体非空将单据加入vector
            onebill.setParentVO(headers[i]);
            billVector.add(onebill);
          }
        }
      }
      // 由vector转换为单据数组
      bills = new DelivbillHVO[billVector.size()];
      billVector.copyInto(bills);
      // showMethodTime("组合VO", startTime);

      // 测试效率用
      long end = getCurrentTime();
      long time = end - start;
      SCMEnv.info("find all deliv bill need time:" + time + "ms");
      //
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    return bills;
  }

  /**
   * 函数的功能、用途、对属性的更改，以及函数执行前后对象的状态。
   * 
   * @param 参数说明
   * @return 返回值
   * @exception 异常描述
   * @see 需要参见的其它内容
   * @since 从类的那一个版本，此方法被添加进来。（可选）
   * @author zhongyue
   * @return java.util.ArrayList
   * @param pkTrancust
   *          java.lang.String
   */
  public ArrayList findRecieveCustlink(String pkTrancust)
      throws BusinessException {
    ArrayList result = new ArrayList();
    try {
      DelivbillHDMO dmo = new DelivbillHDMO();
      result = dmo.findRecieveCustlink(pkTrancust);
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    return result;
  }

  /**
   * 通过主键查找一个VO对象。 创建日期：(2002-5-16)
   * 
   * @return nc.vo.dm.dm001.DelivorgHeaderVO
   * @param key
   *          String
   * @exception java.sql.SQLException
   *              异常说明。
   */
  public String findRouteDescr(String pkroute) throws BusinessException {
    String result;
    try {
      DelivbillHDMO dmo = new DelivbillHDMO();
      result = dmo.findRouteDescr(pkroute);
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    return result;
  }

  /**
   * 函数的功能、用途、对属性的更改，以及函数执行前后对象的状态。
   * 
   * @param 参数说明
   * @return 返回值
   * @exception 异常描述
   * @see 需要参见的其它内容
   * @since 从类的那一个版本，此方法被添加进来。（可选）
   * @author zhongyue
   * @return java.util.ArrayList
   * @param pkroute
   *          java.lang.String
   */
  public ArrayList findRouteDetail(String pkroute) throws BusinessException {
    ArrayList result;
    try {
      DelivbillHDMO dmo = new DelivbillHDMO();
      result = dmo.findRoutedetail(pkroute);
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    return result;
  }

  /**
   * 函数的功能、用途、对属性的更改，以及函数执行前后对象的状态。
   * 
   * @param 参数说明
   * @return 返回值
   * @exception 异常描述
   * @see 需要参见的其它内容
   * @since 从类的那一个版本，此方法被添加进来。（可选）
   * @author zhongyue
   * @return java.util.ArrayList
   * @param pkTrancust
   *          java.lang.String
   */
  public ArrayList findTrancustLink(String pkTrancust) throws BusinessException {
    ArrayList result = new ArrayList();
    try {
      DelivbillHDMO dmo = new DelivbillHDMO();
      result = dmo.findTrancustlink(pkTrancust);
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    return result;
  }

  /**
   * 里程。 创建日期：(2001-8-15 10:08:13)
   */
  public String[] getDestArea(String pk_cumandoc) throws BusinessException {
    String s[] = null;
    try {
      DelivbillHDMO dmo = new DelivbillHDMO();
      s = dmo.getDestArea(pk_cumandoc);

    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    return s;
  }

  /**
   * 读取所有仓库存货现存量信息。 创建日期：(2002-6-19 16:19:30)
   * 
   * @return java.util.ArrayList
   * @param pkinv
   *          java.lang.String
   */
  public OutbillHVO[] getOnhandnum(DelivbillHItemVO[] items, String userid,
      UFBoolean ufbIsConsiderOfOutNum) throws BusinessException {
    // 已加入对发运单表体业务员业务部门的处理
    OutbillHVO[] outbills = null;
    int i, j;
    String pkStoreorg = null, pkcorp = null, pkinv = null;
    InvOnHandVO[] invonhandvos = null;
    try {
      if (null == ufbIsConsiderOfOutNum)
        ufbIsConsiderOfOutNum = new UFBoolean(false);
      if (ufbIsConsiderOfOutNum.booleanValue()) {
        // 根据发运单行对应自由状态出库单汇总应发数量过滤发运单
        items = filterDlvitemsForOut(items);
      }
      else {
        // 根据发运单行对应所有出库单汇总应发数量过滤发运单
        items = filterDlvitemsForOutNoOutNum(items);
      }
      //

      // 根据表体行发货库存组织查询其相应仓库
      ArrayList stores = null;
      ArrayList oneStoreorg = null;
      ArrayList pkStores = null;

      DelivbillHDMO dmo = new DelivbillHDMO();
      stores = dmo.findStoresByCalbody(items, userid);

      // 查得所有存货对应的默认仓库
      Hashtable htInvStore = new Hashtable();
      ArrayList alInvs = new ArrayList();
      Hashtable htInvIDs = new Hashtable();
      for (int w = 0; w < items.length; w++) {
        // skg begin 2003-11-05
        if (!htInvIDs.containsKey(items[w].getAttributeValue("pkinv"))) {
          alInvs.add(items[w].getAttributeValue("pkinv"));
          htInvIDs.put(items[w].getAttributeValue("pkinv"), "");
        }
        // htInvStore= queryInvProduceStoreByInvs(alInvs);
      }
      htInvStore = queryInvProduceStoreByInvs(alInvs);
      // skg end 2003-11-05

      // 组织OutbillHVO
      outbills = new OutbillHVO[items.length];
      for (i = 0; i < items.length; i++) {
        outbills[i] = new OutbillHVO();
        if (items[i] != null) {
          pkStoreorg = items[i].getPksendstockorg();
          pkcorp = items[i].getPksalecorp();
          pkinv = items[i].getPkinv();
          if (pkStoreorg != null) {
            // 查询当前行的仓库id
            for (j = 0; j < stores.size(); j++) {
              oneStoreorg = (ArrayList) stores.get(j);
              if (oneStoreorg != null && oneStoreorg.get(0) != null) {
                if (pkStoreorg.equals(oneStoreorg.get(0).toString().trim()) == true) {
                  // 找到当前发运单表体行发货库存组织对应的仓库pk
                  pkStores = (ArrayList) oneStoreorg.get(1);
                  break;
                }
              }
            }
          } // if(pkStoreorg!=null)
          if (pkStores != null) {
            // 根据这些仓库pk调用库存接口查询现存量并组织生成出库单VO
            OutbillHItemVO[] outbillitems = new OutbillHItemVO[pkStores.size()];
            for (j = 0; j < pkStores.size(); j++)
              if (pkStores.get(j) != null) {
                outbillitems[j] = new OutbillHItemVO();
                outbillitems[j].setPk_delivbill_b(items[i].getPk_delivbill_b());
                outbillitems[j].setPkstroe(((String[]) pkStores.get(j))[0]);
                outbillitems[j].setVstorename(((String[]) pkStores.get(j))[1]);
                // 取现存量参数为：pkcorp,pkwarehouse,pkinv,int,int,int,int
                /*
                 * invonhandvos = invOnhandDmo.getOnHandNum(pkcorp, ((String[])
                 * pkStores.get(j))[0], pkinv, 0, 0, 0, 0); if (invonhandvos !=
                 * null && invonhandvos.length > 0) { //&&
                 * invonhandvos[0].getNmaster() != null //&&
                 * invonhandvos[0].getNmaster().toString().trim().length() != 0
                 * //&& new
                 * UFDouble(invonhandvos[0].getNmaster().toString()).doubleValue() !=
                 * 0) {
                 * outbillitems[j].setDonhandnum(invonhandvos[0].getNmaster()); }
                 */
                nc.bs.dm.pub.fromic.DmFromIcDMO invOnhandDmo = new nc.bs.dm.pub.fromic.DmFromIcDMO();
                UFDouble ufdonhandnum = invOnhandDmo.getOnHandNum(pkcorp,
                    pkStoreorg, ((String[]) pkStores.get(j))[0], pkinv,
                    items[i].getVfree1(), items[i].getVfree2(), items[i]
                        .getVfree3(), items[i].getVfree4(), items[i]
                        .getVfree5(), items[i].getVfree6(), items[i]
                        .getVfree7(), items[i].getVfree8(), items[i]
                        .getVfree9(), items[i].getVfree10(), items[i]
                        .getVbatchcode(), items[i].getPkassistmeasure());

                outbillitems[j].setDonhandnum(ufdonhandnum);
              }
            // 重排表体行仓库，优先：表头仓库，表体存货对应的主仓库，表体数量
            outbillitems = resortStore(items[i], outbillitems, htInvStore);

            outbills[i].setChildrenVO(outbillitems);
          }
          // 2002-10-08-毕晖
          else
            outbills[i].setChildrenVO(null);
          // 2008
          // if (pkStores != null)
        } // if(item[i]!=null)

        // 取得发运单表体行对应日计划的业务员业务部门置入发运单表体
        DelivbillHItemVO newItem = dmo.getPkoperatorForItem(items[i]);
        // 将发运单表体行放入生成出库单VO的表头
        outbills[i].setParentVO(newItem);
      } // for (i= 0; i < items.length; i++)
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }

    return outbills;
  }

  /**
   * 向数据库中插入一个VO对象。 创建日期：(2002-6-3)
   * 
   * @param delivbillH
   *          nc.vo.dm.dm104.DelivbillHVO
   * @return java.lang.String 所插入VO对象的主键字符串。
   * @exception BusinessException
   *              异常说明。
   */
  private ArrayList insert(DelivbillHVO delivbillH, DMDataVO[] dmitems,
      ClientLink clientLink) throws BusinessException {
    String sLockPk[] = null;
    String sUserID = null;
    
    IScm srv = (IScm) NCLocator.getInstance().lookup(IScm.class.getName());    
    srv.checkDefDataType(delivbillH);
    
    try {
      DelivbillHDMO dmo = new DelivbillHDMO();
      // 加锁
      sLockPk = dmo.getLockPKsArray(delivbillH, "pk_delivbill_h",
          "pk_delivbill_b", "pk_delivbill_h", new String[] {
            "pkdayplan"
          }, new String[0]);
      sUserID = clientLink.getUser();
      lockPKs(sLockPk, sUserID);

      //
      if (dmo.isBillCodeDuplicated(delivbillH)) {
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance()
            .getStrByID("40140408", "UPP40140408-000115")/* @res "单据号重复！" */);
      }
      //

      // 新增保存前的上游单据时间戳校验
      checkSourceTsForNewAdd("vdayplancode", "pkdayplan", "sourcebillts",
          new String[] {
            "dm_delivdaypl"
          }, new String[] {
            "pk_delivdaypl"
          }, new String[] {
            "ts"
          }, delivbillH.getChildrenVO());

      
      DelivbillHItemVO[] allBakItems = (DelivbillHItemVO[]) delivbillH
          .getChildrenVO();

      for (int i = 0; i < allBakItems.length; i++) {
        allBakItems[i].setNfeedbacknum(allBakItems[i].getDinvnum());
      }

      // 可用量接口
      nc.bs.dm.pub.toic.DLATP atp = null;
      if (delivbillH.getChildrenVO().length > 0) {
    	 //采购订单生成的发运单不需要修改可用量
    	if(allBakItems[0].getVbilltype() != null
    			&& !"21".equals(allBakItems[0].getVbilltype()))
    	{
    		atp = new nc.bs.dm.pub.toic.DLATP();
    		atp.modifyATP(delivbillH);
    	}
      }

      ArrayList keylist = dmo.insert(delivbillH, clientLink);

      // 进行按钮注册
      signButtonClickTime(RecordType.SAVESEND, delivbillH, false);

      if (dmitems != null) {
        nc.impl.dm.dm102.DeliverydailyplanImpl remote = new nc.impl.dm.dm102.DeliverydailyplanImpl();
        remote.setSendNum(dmitems);
      }

      // v5增加：可用量即时校验
      if (atp != null) {
        atp.checkAtpInstantly(delivbillH, null);
      }
      return keylist;
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    finally {
      // 解锁
      unLockPKs(sLockPk, sUserID);
    }
  }

  /**
   * 创建者：王乃军 功能： 参数： String sMethodName, 方法名 Class[] caParamClassList, 参数类型列表
   * Object[] oaParamValueList 参数 返回： 例外： 日期：(2001-5-9 9:23:32)
   * 修改日期，修改人，修改原因，注释标志：
   */
  private Object invokeMethodRun(String sClassName, String sMethodName,
      Class[] caParamClassList, Object[] oaParamValueList) throws Exception {
    try {
      // 生成类
      Class cMyClass = Class.forName(sClassName);
      // 调用
      // cMyClass.isInterface();
      // DmDMO dmdmotemp= new DmDMO();
      // cMyClass.newInstance();
      return cMyClass.getMethod(sMethodName, caParamClassList).invoke(
          cMyClass.newInstance(), oaParamValueList);
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }

  }

  /**
   * 此处插入方法说明。 功能：查询对应业务类型的收发类别 参数： 返回： 例外： 日期：(2002-10-7 11:51:17)
   * 修改日期，修改人，修改原因，注释标志：
   * 
   * @return java.lang.String
   * @param sCbiztype
   *          java.lang.String
   * @exception BusinessException
   *              异常说明。
   */
  public String queryDispatcherForCbiztype(String sCbiztype)
      throws BusinessException {
    StringBuffer sb = new StringBuffer();
    sb.append(" select bd_busitype.verifyrule ").append(
        " from bd_busitype where bd_busitype.dr=0 ");
    sb.append(" and  bd_busitype.pk_busitype='" + sCbiztype + "'");

    SmartDMO smartDMO = null;
    try {
      smartDMO = new SmartDMO();

      // 查得费用构成项属性表
      Object[] obj = smartDMO.selectBy2(sb.toString());
      if (null != obj && obj.length == 1 && obj[0] != null
          && ((Object[]) obj[0])[0] != null)
        return ((Object[]) obj[0])[0].toString();

      return "";
    }
    catch (Exception e) {
      reportException(e);
      throw new BusinessException(e);
    }

  }

  /**
   * 此处插入方法说明。 功能：查询发运方式对应的费用项 参数： 返回： 例外： 日期：(2002-8-29 16:33:39)
   * 修改日期，修改人，修改原因，注释标志：
   * 
   * @return nc.vo.dm.pub.DMDataVO
   * @param sWhereClause
   *          java.lang.String
   * @exception BusinessException
   *              异常说明。
   */
  public nc.vo.dm.pub.DMDataVO[] queryFeeItemFormula(String sWhereClause)
      throws BusinessException {
    try {
      DelivbillHDMO dmo = new DelivbillHDMO();
      return dmo.queryFeeItemFormula(sWhereClause);
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * 此处插入方法说明。 功能：查询运费构成项和属性 参数： 返回： 例外： 日期：(2002-8-29 16:33:39)
   * 修改日期，修改人，修改原因，注释标志：
   * 
   * @return nc.vo.dm.pub.DMDataVO
   * @param sWhereClause
   *          java.lang.String
   * @exception BusinessException
   *              异常说明。
   */
  public nc.vo.dm.pub.DMDataVO queryForitem(String sWhereClause)
      throws BusinessException {
    try {
      DelivbillHDMO dmo = new DelivbillHDMO();
      return dmo.queryForitem(sWhereClause);
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * 此处插入方法说明。 功能：查询存货管理档案对应的主仓库ID 参数： 返回： 例外： 日期：(2002-8-29 16:33:39)
   * 修改日期，修改人，修改原因，注释标志：
   * 
   * @return nc.vo.dm.pub.DMDataVO
   * @param sWhereClause
   *          java.lang.String
   * @exception BusinessException
   *              异常说明。
   */
  private Hashtable queryInvProduceStoreByInvs(ArrayList alInvs)
      throws BusinessException {
    try {
      Hashtable ht = new Hashtable();
      StringBuffer sql = new StringBuffer();
      sql
          .append(
              "select bd_produce.pk_invmandoc,bd_produce.pk_stordoc from bd_produce ")
          .append(
              " inner join bd_stordoc on bd_produce.pk_stordoc=bd_stordoc.pk_stordoc and ")
          .append(" bd_stordoc.isdirectstore='N' and bd_stordoc.gubflag='N'");
      String sWhere = "";
      // skg begin 2003-11-04
      /*
       * for (int i= 0; i < alInvs.size(); i++) { if (null != alInvs.get(i)) {
       * if (sWhere.trim().length() == 0) { sWhere= " where pk_invmandoc in ('" +
       * alInvs.get(i) + "'"; } else { sWhere= sWhere + ",'" + alInvs.get(i) +
       * "'"; } } }
       */
      String[] sAllPKs = (String[]) alInvs.toArray(new String[0]);
      DMDataVO votool = new DMDataVO();
      String pkinvs = votool.getStrPKs("pk_invmandoc", sAllPKs).toString();
      sWhere = " where " + pkinvs;
      // skg end 2003-11-04
      if (sWhere.trim().length() == 0) {
        return ht;
      }
      // sql.append(sWhere + " ) ");
      sql.append(sWhere);

      DMDataVO[] dmdvos = query(sql);

      for (int i = 0; i < dmdvos.length; i++) {
        if (null != dmdvos[i].getAttributeValue("pk_invmandoc")
            && null != dmdvos[i].getAttributeValue("pk_stordoc")) {
          ht.put(dmdvos[i].getAttributeValue("pk_invmandoc").toString(),
              dmdvos[i].getAttributeValue("pk_stordoc").toString());
        }
      }

      return ht;
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * 此处插入方法说明。 功能：依发货库存组织查对应的地区的ID和名称 参数： 返回： 例外： 日期：(2002-10-7 11:51:17)
   * 修改日期，修改人，修改原因，注释标志：
   * 
   * @return java.lang.String
   * @param sCbiztype
   *          java.lang.String
   * @exception BusinessException
   *              异常说明。
   */
  public String[] queryLocalNameIDForSendCalBody(String sSendCalBody)
      throws BusinessException {
    try {
      String sWhereClause = " bd_calbody.pk_calbody='" + sSendCalBody + "'";
      DelivbillHDMO dmo = new DelivbillHDMO();
      return dmo.queryLocalNameIDForSendCalBody(sWhereClause);
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * 创建日期：(2003-11-4 14:35:07) 作者：仲瑞庆 参数： 返回： 说明：
   * 
   * @return nc.vo.dm.pub.DMDataVO[]
   */
  public DMDataVO[] queryLocalNameIDForSendCalBodyS(Hashtable htSendCalBody)
      throws BusinessException {
    try {
      DMDataVO ddvo = new DMDataVO();
      Object[] oCondition = ddvo.getAllKeysFromHashtable(htSendCalBody);
      if (null != oCondition) {
        String[] sCondition = new String[oCondition.length];
        for (int i = 0; i < oCondition.length; i++) {
          sCondition[i] = (String) oCondition[i];
        }
        String sWhereClause = ddvo.getStrPKs("bd_calbody.pk_calbody",
            sCondition).toString();
        // String sWhereClause= " bd_calbody.pk_calbody='" + sSendCalBody + "'";
        DelivbillHDMO dmo = new DelivbillHDMO();
        return dmo.queryLocalNameIDForSendCalBodyS(sWhereClause);
      }
      else {
        return null;
      }
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * 此处插入方法说明。 功能：查询包装分类的VO数组 参数： 返回： 例外： 日期：(2002-8-31 14:05:30)
   * 修改日期，修改人，修改原因，注释标志：
   * 
   * @return nc.vo.dm.pub.DMDataVO
   * @param sWhereClause
   *          java.lang.String
   * @exception BusinessException
   *              异常说明。
   */
  public nc.vo.dm.pub.DMDataVO queryPackageItem(String sWhereClause)
      throws BusinessException {
    try {
      DelivbillHDMO dmo = new DelivbillHDMO();
      return dmo.queryPackageItem(sWhereClause);
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * @author 仲瑞庆 函数的功能、用途、对属性的更改，以及函数执行前后对象的状态。 重排出库行,优先为:先表头仓库,再默认仓库,再其他仓库中依现存量
   * @param 参数说明
   * @return 返回值
   * @exception 异常描述
   * @see 需要参见的其它内容
   * @since 从类的那一个版本，此方法被添加进来。（可选） (2002-11-20 8:37:10)
   * @param delivItemVOs
   *          nc.vo.dm.dm104.DelivbillHItemVO[]
   * @param outbillItemVOs
   *          nc.vo.dm.dm104.OutbillHItemVO[]
   */
  private OutbillHItemVO[] resortStore(DelivbillHItemVO delivItemVO,
      OutbillHItemVO[] outbillItemVOs, Hashtable htInvStore)
      throws BusinessException {

    Object pksendstock = delivItemVO.getAttributeValue("pksendstock"); // 发货仓库
    String pkinv = delivItemVO.getAttributeValue("pkinv").toString(); // 存货
    if (pksendstock == null || pksendstock.toString().trim().length() == 0) {
      pksendstock = "";
    }

    // 先对表体依数量排序
    DMVO dmvo = new DMVO();
    DMDataVO[] dmdvos = new DMDataVO[outbillItemVOs.length];
    for (int i = 0; i < dmdvos.length; i++) {
      dmdvos[i] = new DMDataVO();
      dmdvos[i] = dmdvos[i].translateFromOtherVO(outbillItemVOs[i]);
    }
    dmvo.setChildrenVO(dmdvos);
    dmvo.sortByKeys(new String[] {
      "donhandnum"
    }, new int[] {
      SortType.DESC
    });

    outbillItemVOs = new OutbillHItemVO[dmvo.getBodyVOs().length];
    for (int i = 0; i < dmvo.getBodyVOs().length; i++) {
      outbillItemVOs[i] = new OutbillHItemVO();
      dmvo.getBodyVOs()[i].translateToOtherVO(outbillItemVOs[i]);
    }

    Vector vOutBillItem = new Vector();

    // 将特殊的仓库行提前
    for (int i = 0; i < outbillItemVOs.length; i++) {
      String sPkstroe = (String) outbillItemVOs[i].getAttributeValue("pkstroe"); // 表体仓库
      if (null != sPkstroe && pksendstock.equals(sPkstroe)) {
        vOutBillItem.add(0, outbillItemVOs[i]);
        continue;
      }
      if (htInvStore.containsKey(pkinv)
          && htInvStore.get(pkinv).toString().trim().equals(sPkstroe)) {
        if (vOutBillItem.size() > 0
            && pksendstock.equals(((OutbillHItemVO) vOutBillItem.get(0))
                .getAttributeValue("pkstroe"))) {
          // 已置入发货仓库
          vOutBillItem.add(1, outbillItemVOs[i]);
          continue;
        }
        else {
          vOutBillItem.add(0, outbillItemVOs[i]);
          continue;
        }
      }
      vOutBillItem.add(outbillItemVOs[i]);
    }

    OutbillHItemVO[] newOutbillItemVOs = new OutbillHItemVO[vOutBillItem.size()];
    vOutBillItem.copyInto(newOutbillItemVOs);
    return newOutbillItemVOs;
  }

  /**
   * 保存校验。 功能：检查时间戳，外关联，以及唯一性校验 参数：vo 返回：void 例外： 日期：(2002-9-18 11:03:32)
   * 修改日期，修改人，修改原因，注释标志：
   * 
   * @return java.util.ArrayList
   * @exception nc.ui.bd.datainit.BusinessException
   *              异常说明。
   */
  private void saveCheck(DelivbillHVO vo, ClientLink clientLink)
      throws BusinessException, BusinessException,
      javax.naming.NamingException, java.sql.SQLException {
    IScm srv = (IScm) NCLocator.getInstance().lookup(IScm.class.getName());    
    srv.checkDefDataType(vo);

    // 当为修改或删除时
    if (vo.getParentVO().getStatus() != nc.vo.pub.VOStatus.NEW) {
      timeStampCheck(vo);
    }

    if (vo.getParentVO().getStatus() == nc.vo.pub.VOStatus.DELETED) {
      boolean flag = false;
      try {
        // 当为删除时，校验是否有其他表调用要删除的数据
        IReferenceCheck refCheck = (IReferenceCheck) nc.bs.framework.common.NCLocator
            .getInstance().lookup(IReferenceCheck.class.getName());
        // ReferenceManagerDMO refCheck = new ReferenceManagerDMO();
        flag = refCheck.isReferenced("bd_DelivbillHVO", vo.getParentVO()
            .getPrimaryKey());
      }
      catch (Exception ex) {
        throw new BusinessException(ex);
      }
      // 判断是否有其他数据引用该记录
      if (flag) {
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance()
            .getStrByID("40140408", "UPP40140408-000116")/*
                                                           * @res
                                                           * "很抱歉，系统其他数据引用了该记录！系统不允许删除。"
                                                           */);
      }
    }

  }

  /**
   * 作者：毕晖 保存发运单包装分类数量表。 创建日期：(2002-5-17 14:27:23)
   * 
   * @param vos
   *          nc.vo.dm.pub.DMDataVO[]
   */
  private DMDataVO[] saveDelivPackNum(nc.vo.dm.pub.DMDataVO[] vos)
      throws BusinessException {
    if (vos == null || vos.length == 0) {
      return null;
    }
    try {
      DMVO vo = new DMVO();
      vo.setChildrenVO(vos);

      String sDelivBillID = vos[0].getAttributeValue("pk_delivbill_h")
          .toString();
      // 删除下游到货通知
      // nc.bs.dm.dm124.TransInfoDMO transDMO = new
      // nc.bs.dm.dm124.TransInfoDMO();
      // transDMO.delete(sDelivBillID);
      // 删除原包装明细
      DelivbillHDMO dmo = new DelivbillHDMO();
      StringBuffer sbfDeleteSql = new StringBuffer();
      sbfDeleteSql
          .append("delete from dm_delivpacknum where pk_delivbill_h = '"
              + sDelivBillID + "'");
      dmo.saveExecute(sbfDeleteSql);

      vo.filterNullValueRow(new String[] {
          "dpacknum", "pkinvclass", "doneweight", "dweight", "dvolumn"
      });

      vo = super.save(null, "dm_delivpacknum", vo, null,
          new ValueRangeHashtableDelivPackNum(), true);
      return vo.getBodyVOs();
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * 此处插入方法说明。 功能：保存发运单包装分类数量表 和 运费单 更新发运单 参数： 返回： 例外： 日期：(2002-9-4 20:40:39)
   * 修改日期，修改人，修改原因，注释标志：
   * 
   * @param DelivPackNumVO
   *          nc.vo.dm.pub.DMDataVO[]
   * @param TransFeeVO
   *          nc.vo.dm.pub.DMVO
   * @exception BusinessException
   *              异常说明。
   */
  public ArrayList saveDelivPackNumAndTransFeeVO(DMDataVO[] DelivPackNumVO,
      DelivfeebillHVO TransFeeVO, DelivbillHVO DelivBillVO,
      ClientLink clientLink) throws BusinessException {
    // 未考虑加锁

    ArrayList resultlist = null;

    saveDelivPackNum(DelivPackNumVO);

    // 传入发运单,执行修改表头发运方式的行为,要做VO校验
    // 暂时注释，待改完此方法后再行使用
    if (DelivBillVO != null)
      resultlist = updateDelivbill(DelivBillVO, null, false, clientLink);

    // 删除相应运费单
    deleteTransFeeBillVO(DelivBillVO);

    if (null != TransFeeVO && TransFeeVO.getParentVO() != null
        && TransFeeVO.getDBChildrenVO() != null
        && TransFeeVO.getDBChildrenVO().length != 0) {
      try {
        // 处理传运费单开票客户pkarrivecorp
        preparePkCustForTransFee(TransFeeVO, DelivBillVO, clientLink);

        // 插入新的运费单
        nc.impl.dm.dm107.DelivfeebillHImpl remote = new nc.impl.dm.dm107.DelivfeebillHImpl();
        remote.insertDelivfeebill(TransFeeVO);
      }
      catch (Exception e) {
        reportException(e);
        if (e instanceof BusinessException)
          throw (BusinessException) e;
        else
          throw new BusinessException(e);
      }
      // finally {
      // //removeRemoteBO(remote);
      // }
    }
    return resultlist;
  }

  /**
   * 此处插入方法说明。 功能：准备开票客户 修改日期，修改人，修改原因，注释标志：
   * 
   * @param DelivPackNumVO
   *          nc.vo.dm.pub.DMDataVO[]
   * @param TransFeeVO
   *          nc.vo.dm.pub.DMVO
   * @exception BusinessException
   *              异常说明。
   */
  private void preparePkCustForTransFee(DelivfeebillHVO TransFeeVO,
      DelivbillHVO DelivBillVO, ClientLink clientLink) throws BusinessException {
    try {
      // 处理传运费单开票客户pkarrivecorp
      DelivbillHItemVO[] delivbodyvos = (DelivbillHItemVO[]) DelivBillVO
          .getChildrenVO();
      Hashtable htIDToDelivItem = new Hashtable();
      for (int i = 0; i < delivbodyvos.length; i++) {
        htIDToDelivItem.put(delivbodyvos[i].getPrimaryKey(), delivbodyvos[i]);
      }
      ArrayList alChgSo = new ArrayList();
      ArrayList alChgTo = new ArrayList();
      ArrayList alFeeVOSo = new ArrayList();
      ArrayList alFeeVOTo = new ArrayList();
      ArrayList alFeeVOother = new ArrayList();
      DelivfeebillHItemVO[] transbodyvos = (DelivfeebillHItemVO[]) TransFeeVO
          .getDBChildrenVO();
      for (int i = 0; i < transbodyvos.length; i++) {
        ChgDocPkVO chgvo = new ChgDocPkVO();
        // 转化为客户
        chgvo.setStrDstCustflag(new String[] {
            "0", "2"
        });
        DelivbillHItemVO delivitem = (DelivbillHItemVO) htIDToDelivItem
            .get(transbodyvos[i].getPk_delivbill_b());
        chgvo.setSrcManId(delivitem.getPkcusmandoc());
        chgvo.setDstCorpId(clientLink.getCorp());
        if (delivitem.getVbilltype().equals("5C")
            || delivitem.getVbilltype().equals("5E")) {
          chgvo.setSrcCorpId(delivitem.getPkarrivecorp());
          alChgTo.add(chgvo);
          alFeeVOTo.add(transbodyvos[i]);
        }
        else if (delivitem.getVbilltype().equals("30")) {
          chgvo.setSrcCorpId(delivitem.getPksalecorp());
          alChgSo.add(chgvo);
          alFeeVOSo.add(transbodyvos[i]);
        }
        else
          alFeeVOother.add(transbodyvos[i]);
      }
      // 转换
      ChgDocPkVO[] chgvoSO = (ChgDocPkVO[]) alChgSo.toArray(new ChgDocPkVO[0]);
      ChgDocPkVO[] chgvoTO = (ChgDocPkVO[]) alChgTo.toArray(new ChgDocPkVO[0]);
      ChgDataUtil.chgPkCuByCorp(chgvoSO);
      ChgDataUtil.chgInnerCorpToCust(chgvoTO);
      // 拼回
      DelivfeebillHItemVO[] transbodyvosSO = (DelivfeebillHItemVO[]) alFeeVOSo
          .toArray(new DelivfeebillHItemVO[0]);
      DelivfeebillHItemVO[] transbodyvosTO = (DelivfeebillHItemVO[]) alFeeVOTo
          .toArray(new DelivfeebillHItemVO[0]);
      for (int i = 0; i < transbodyvosSO.length; i++) {
        transbodyvosSO[i].setPkcustinvoice(chgvoSO[i].getDstManId());
        alFeeVOother.add(transbodyvosSO[i]);

      }
      for (int i = 0; i < transbodyvosTO.length; i++) {
        transbodyvosTO[i].setPkcustinvoice(chgvoTO[i].getDstManId());
        alFeeVOother.add(transbodyvosTO[i]);
      }
      DelivfeebillHItemVO[] transbodyvosAll = (DelivfeebillHItemVO[]) alFeeVOother
          .toArray(new DelivfeebillHItemVO[0]);
      TransFeeVO.setDBChildrenVO(transbodyvosAll);
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * 库存方面回写发运单的实际出库数量。 作者：zxping 2005-6-2 17:18 给库存提供的接口
   * 
   * @param vos
   * @param clientLink
   * @throws Exception
   */
  public void setOutnum(DMDataVO[] vos, ClientLink clientLink)
      throws Exception, BusinessException {

    try {
      HashSet hsDelivBill = new HashSet();

      for (int i = 0; i < vos.length; i++) {
        hsDelivBill.add(vos[i].getAttributeValue("pksourceb"));
      }

      String[] sDelivBillBodyPKs = new String[hsDelivBill.size()];

      hsDelivBill.toArray(sDelivBillBodyPKs);
      // 根据条件得到需要更新的发运单
      String itemWhere = new DMDataVO().getStrPKs(
          "dm_delivbill_b.pk_delivbill_b", sDelivBillBodyPKs)
          + " and dm_delivbill_b.dr=0 ";

      String headWhere = " dm_delivbill_h.pk_delivbill_h in "
          + " (select distinct body.pk_delivbill_h from dm_delivbill_b body where "
          + new DMDataVO().getStrPKs("body.pk_delivbill_b", sDelivBillBodyPKs)
          + " and body.dr=0 ) ";

      String pkdo = null;
      DelivbillHVO[] delivBills = findDelivBills(pkdo, headWhere, itemWhere);

      for (int i = 0; i < delivBills.length; i++) {
        delivBills[i].setStatus(nc.vo.pub.VOStatus.UPDATED);

        DelivbillHItemVO[] items = (DelivbillHItemVO[]) delivBills[i]
            .getChildrenVO();

        ArrayList alClosedItems = new ArrayList(); // 已关闭状态发运单或已出库结束发运单行
        ArrayList alFreeItems = new ArrayList();// 自由状态发运单行
        for (int j = 0; j < items.length; j++) {
          items[j].setStatus(nc.vo.pub.VOStatus.UPDATED);

          if (items[j].getBcloseout() != null
              && items[j].getBcloseout().booleanValue()) {
            String message = NCLangResOnserver.getInstance().getStrByID(
                "40140408", "UPP40140408-000201");
            /* @res "发运单已经行出库关闭" */
            throw new BusinessException(message);
          }

          // 出库单回写的时候，提供的出库数量是一个差值
          // 设置发运单表体行的实际出库数量
          setDelivBillOutNum(items[j], vos);

          Integer rowStatus = (Integer) items[j].getIrowstatus();
          UFBoolean ufb = (UFBoolean) items[j].getBcloseout();
          ufb = ufb == null ? UFBoolean.FALSE : ufb;
          if (rowStatus.intValue() == DelivBillStatus.End
              || (rowStatus.intValue() == DelivBillStatus.Audit && ufb
                  .booleanValue())) {
            alClosedItems.add(items[j]);
          }
          else {
            alFreeItems.add(items[j]);
          }
        }

        if (alClosedItems.size() > 0) {
          delivBills[i].setChildrenVO((DelivbillHItemVO[]) alClosedItems
              .toArray(new DelivbillHItemVO[alClosedItems.size()]));

          // 回写日计划的VO
          DMDataVO[] writeBackItems = DelivBillVOTool.getWriteBackBill(
              delivBills[i], (DelivbillHHeaderVO) delivBills[i].getParentVO(),
              items, clientLink); // 由修改前的单据和修改后的单据得到回写日计划的单据
          // updateForWriteBackOutNum(DelivbillHVO delivbill,DMDataVO[]
          // writeBackItems, boolean isEnd,ClientLink clientLink)
          updateForWriteBackOutNum(delivBills[i], writeBackItems, true,
              clientLink);
        }

        if (alFreeItems.size() > 0) {
          delivBills[i].setChildrenVO((DelivbillHItemVO[]) alFreeItems
              .toArray(new DelivbillHItemVO[alFreeItems.size()]));

          // 回写日计划的VO
          DMDataVO[] writeBackItems = DelivBillVOTool.getWriteBackBill(
              delivBills[i], (DelivbillHHeaderVO) delivBills[i].getParentVO(),
              items, clientLink); // 由修改前的单据和修改后的单据得到回写日计划的单据
          updateForWriteBackOutNum(delivBills[i], writeBackItems, false,
              clientLink);
        }
      }

    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * 出库单回写的时候，提供的出库数量是一个差值 设置发运单表体行的出库数量
   */
  private void setDelivBillOutNum(DelivbillHItemVO item, DMDataVO[] vos) {
    for (int i = 0; i < vos.length; i++) {
      String pksourceb = (String) vos[i].getAttributeValue("pksourceb");
      if (item.getPk_delivbill_b().equals(pksourceb)) {
        UFDouble ufd = item.getDoutnum();
        if (ufd == null)
          ufd = new UFDouble(0.0);
        UFDouble ufdIncrease = (UFDouble) vos[i].getAttributeValue("noutnum");
        if (ufdIncrease == null)
          ufdIncrease = new UFDouble(0.0);
        ufd = ufd.add(ufdIncrease);

        item.setDoutnum(ufd);

        // 销售出库单回写发运单，提供一个出库数量的差值
        item.setDoutnumMargin(ufdIncrease);

        break;
      }
    }
  }

  /**
   * 生成出库单。 功能： 参数： 返回： 例外： 日期：(2002-9-10 10:33:14) 修改日期，修改人，修改原因，注释标志：
   * 
   * @return nc.vo.pub.lang.UFBoolean
   * @param vos
   *          nc.vo.ic.pub.bill.GeneralBillVO[]
   */
  public String saveOutDM(GeneralBillVO[] vos,
      nc.vo.pub.lang.UFDateTime newTime, DelivbillHVO dlvbillhvo,
      ClientLink clientLink) throws BusinessException {

    String[] sLockPk = null;
    String resultTs = null;

    try {
      DelivbillHDMO dmo = new DelivbillHDMO();

      // 加锁
      sLockPk = dmo.getLockPKsArray(dlvbillhvo, "pk_delivbill_h",
          "pk_delivbill_b", "pk_delivbill_h", new String[] {
            "pkdayplan"
          }, new String[0]);

      lockPKs(sLockPk, clientLink.getUser());

      // 调用校验方法
      saveCheck(dlvbillhvo, clientLink);

      // IC2DMInterface ic2dm = new IC2DMInterface();
      if (!getICInter().saveOutDM(vos).booleanValue()) {
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance()
            .getStrByID("40140408", "UPP40140408-000117")/*
                                                           * @res
                                                           * "发运单推式保存出库单失败!"
                                                           */);
      }

      // 按钮动作记录
      if (vos != null)
        for (int i = 0; i < vos.length; i++)
          signButtonClickTimeOutbill(RecordType.SAVEOUT, newTime, vos[i], false);

      DelivbillHItemVO[] items = (DelivbillHItemVO[]) dlvbillhvo
          .getChildrenVO();
      // 设置表体状态
      for (int i = 0; i < items.length; i++) {
        items[i].setIrowstatus(new Integer(DelivBillStatus.Out));
        items[i].setStatus(nc.vo.pub.VOStatus.UPDATED);
      }

      java.util.ArrayList ary = updateGeneral(dlvbillhvo, null, true, false,
          clientLink);
      if (null != ary && ary.size() > 0) {
        if (dlvbillhvo.getParentVO() != null) {
          dlvbillhvo.getParentVO().setAttributeValue("ts",
              ary.get(ary.size() - 1));
        }
        resultTs = (String) ary.get(ary.size() - 1);
      }

    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    finally {
      // 解锁
      unLockPKs(sLockPk, clientLink.getUser());
    }

    return resultTs;
  }

  /**
   * 此处插入方法说明。 功能：签下按钮动作时的时间记录 参数： 返回： 例外： 日期：(2002-10-4 13:01:11)
   * 修改日期，修改人，修改原因，注释标志：
   * 
   * @param sOperateType
   *          java.lang.String
   * @param vo
   *          nc.vo.pub.AggregatedValueObject
   * @exception BusinessException
   *              异常说明。
   */
  protected void signButtonClickTime(String sOperateType,
      AggregatedValueObject vo, boolean bIsUnDo) throws BusinessException {

    String sBillType = DMBillTypeConst.m_delivDelivBill;
    String sSourceFieldKeyInBodyVO = "pkorder";

    String sBillID = vo.getParentVO().getAttributeValue("pk_delivbill_h") == null ? null
        : vo.getParentVO().getAttributeValue("pk_delivbill_h").toString();
    String sCorpID = vo.getParentVO().getAttributeValue("pkcorpforgenoid")
        .toString();
    UFDateTime sBillTime = vo.getParentVO().getAttributeValue("billnewaddtime") == null ? null
        : (UFDateTime) vo.getParentVO().getAttributeValue("billnewaddtime");

    try {
      DelivbillHDMO dmo = new DelivbillHDMO();

      Hashtable htcorp = new Hashtable();
      CircularlyAccessibleValueObject[] vos = vo.getChildrenVO();
      for (int i = 0; i < vos.length; i++) {
        String vbilltype = (String) vos[i].getAttributeValue("vbilltype");
        String sRegisterdCorpID = (String) vos[i]
            .getAttributeValue("pksalecorp");
        if (vbilltype.equals("21")) {// 采购订单生成的日计划
          if (vos[i].getAttributeValue("borderreturn").toString().equals("Y")) { // 退货
            sRegisterdCorpID = (String) vos[i].getAttributeValue("pksalecorp");
          }
          else {// 自提
            sRegisterdCorpID = (String) vos[i]
                .getAttributeValue("pkarrivecorp");
          }
        }
        else {// 销售 和 调拨订单生成的日计划
          sRegisterdCorpID = (String) vos[i].getAttributeValue("pksalecorp");
        }

        htcorp.put(sRegisterdCorpID, "");
      }

      java.util.Enumeration enumr = htcorp.keys();
      while (enumr.hasMoreElements()) {
        sCorpID = enumr.nextElement().toString().trim();
        dmo.signButtonClickTime(sOperateType, sBillTime, sBillType, sBillID,
            sCorpID, vo, sSourceFieldKeyInBodyVO, bIsUnDo);
      }

    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }

  }

  /**
   * 此处插入方法说明。 功能：签下按钮动作时的时间记录 参数： 返回： 例外： 日期：(2002-10-4 13:01:11)
   * 修改日期，修改人，修改原因，注释标志：
   * 
   * @param sOperateType
   *          java.lang.String
   * @param vo
   *          nc.vo.pub.AggregatedValueObject
   * @exception BusinessException
   *              异常说明。
   */
  protected void signButtonClickTimeOutbill(String sOperateType,
      UFDateTime sBillTime, AggregatedValueObject vo, boolean bIsUnDo)
      throws BusinessException {

    String sSourceFieldKeyInBodyVO = "cfirstbillhid";

    nc.vo.ic.pub.bill.GeneralBillHeaderVO header = ((nc.vo.ic.pub.bill.GeneralBillHeaderVO) vo
        .getParentVO());

    String sBillID = header.getPrimaryKey();
    String sCorpID = header.getPk_corp();
    String sBillType = header.getCbilltypecode();

    try {
      DelivbillHDMO dmo = new DelivbillHDMO();
      dmo.signButtonClickTime(sOperateType, sBillTime, sBillType, sBillID,
          sCorpID, vo, sSourceFieldKeyInBodyVO, bIsUnDo);

    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }

  }

  /**
   * 作者：仲瑞庆 功能：为实现发运单推式生成入库单，做VO转换前的分单 参数：vos 需要分单的转换前7X类型单据数组 返回：分单完成后的7X类型单据数组
   * 例外： 日期：(2002-4-2 9:57:36) 修改日期，修改人，修改原因，注释标志：
   */
  public DelivConvertToOutHVO[] splitVOForICOutBill(DelivConvertToOutHVO[] vos)
      throws BusinessException {

    DelivConvertToOutHVO[] resultVOs = null;
    String pk_corp = null;
    try {
      nc.bs.dm.dm104.DelivbillHDMO pubDmo = new nc.bs.dm.dm104.DelivbillHDMO();
      // 默认分单方式为“仓库”
      String splitMode = "仓库";/*-=notranslate=-*/
      Hashtable htForSplitMode = new Hashtable(); // 记录各公司的分单方式
      for (int i = 0; i < vos.length; i++) {
        pk_corp = vos[i].getChildrenVO()[0].getAttributeValue("pksalecorp")
            .toString();
        if (htForSplitMode.containsKey(pk_corp)) {
        }
        else {
          // 取得分单方式
          try {
            splitMode = getICParaString(pk_corp, new String[] {
              "IC035"
            })[0].trim();
          }
          catch (Exception e) {
            splitMode = "仓库";/*-=notranslate=-*/
            /** <needn't>需要如此实现。zxping 20050617 */
          }
          htForSplitMode.put(pk_corp, splitMode);
        }
      }

      // 如果订单行“仓库”字段为空，取存货默认仓库
      Hashtable table = null;
      // Vector vCbaseids= new Vector();
      DelivConvertToOutHItemVO[] items = null;
      // String[] cBaseids= null;
      // 取的没有对应仓库的存货管理ID集合
      // for (int i= 0; i < vos.length; i++) {
      // items= vos[i].getBodyVO();
      // //for (int j= 0; j < items.length; j++) {
      // //if (items[j].getCwarehouseid() == null ||
      // items[j].getCwarehouseid().trim().equals("")) {
      // ////if (!vCbaseids.contains(items[i].getCbaseid())) {
      // //if (!vCbaseids.contains(items[j].getCbaseid())) {
      // //vCbaseids.addElement(items[j].getCbaseid());
      // //}
      // //}
      // //}
      // }
      // 取得存货的默认仓库
      // if (vCbaseids != null && vCbaseids.size() > 0) {
      // cBaseids= new String[vCbaseids.size()];
      // vCbaseids.copyInto(cBaseids);
      // table= pubDmo.fetchArrayValue("bd_produce", "pk_stordoc",
      // "pk_invbasdoc", cBaseids);
      // if (table == null || table.size() <= 0)
      // throw new BusinessException("没有找到存货相应的仓库，无法生成采购入库单！");
      // }

      // if (table != null && table.size() > 0) {
      // for (int i= 0; i < vos.length; i++) {
      // items= (OrderItemVO[]) vos[i].getChildrenVO();
      // for (int j= 0; j < items.length; j++) {
      // if (items[j].getCwarehouseid() == null ||
      // items[j].getCwarehouseid().trim() == "") {
      // if (table.containsKey(items[j].getCbaseid()))
      // items[j].setCwarehouseid((String) table.get(items[j].getCbaseid()));
      // else
      // throw new BusinessException("没有找到存货相应的仓库，无法生成采购入库单！");
      // }
      // }
      // }
      // }

      // 按仓库分单
      if (splitMode.equalsIgnoreCase("仓库")) {/*-=notranslate=-*/
        resultVOs = (DelivConvertToOutHVO[]) nc.vo.scm.pub.vosplit.SplitBillVOs
            .getSplitVOs("nc.vo.dm.dm104.DelivConvertToOutHVO",
                "nc.vo.dm.dm104.DelivConvertToOutHHeaderVO",
                "nc.vo.dm.dm104.DelivConvertToOutHItemVO", vos, null,
                new String[] {
                    "vcustcode", "pkdeststockorg", "pkorder", "voutbilltype",
                    "pkstroe"
                });
      }

      // 按仓库+保管员分单
      else if (splitMode.equalsIgnoreCase("仓库+保管员")) {/*-=notranslate=-*/
        //
        // String[] cInventoryids= null;
        // String[] cWarehouseids= null;
        // Vector vInvids= new Vector();
        // Vector vWarehouseids= new Vector();
        String cinvid = null;
        String cwarehouseid = null;
        // Vector vInvAndStores= new Vector();
        // for (int i= 0; i < vos.length; i++) {
        // items= (DelivConvertToOutHItemVO[]) vos[i].getChildrenVO();
        // for (int j= 0; j < items.length; j++) {
        // cinvid= items[j].getAttributeValue("pkinv").toString();
        // cwarehouseid= items[j].getAttributeValue("pkstroe").toString();
        // if (cwarehouseid != null
        // && cwarehouseid.trim() != ""
        // && !vInvAndStores.contains(cinvid + cwarehouseid)) {
        // vInvids.addElement(cinvid == null ? "" : cinvid);
        // vWarehouseids.addElement(cwarehouseid);
        // }
        // }
        // }
        // if (vInvAndStores.size() > 0) {
        // cInventoryids= new String[vInvids.size()];
        // vInvids.copyInto(cInventoryids);
        // cWarehouseids= new String[vWarehouseids.size()];
        // vWarehouseids.copyInto(cWarehouseids);
        // }
        // 调用库存管理接口取得库管员
        nc.bs.dm.pub.fromic.DmFromIcDMO storedmo = new nc.bs.dm.pub.fromic.DmFromIcDMO();
        // table = storedmo.get(pk_corp, null, cWarehouseids,cInventoryids);

        // 库管员赋值
        for (int i = 0; i < vos.length; i++) {
          items = (DelivConvertToOutHItemVO[]) vos[i].getChildrenVO();
          for (int j = 0; j < items.length; j++) {
            cinvid = items[j].getAttributeValue("pkinv").toString();
            cwarehouseid = items[j].getAttributeValue("pkstroe").toString();
            if (cwarehouseid != null && cwarehouseid.trim() != "") {
              items[j].setAttributeValue("pkwhmanager", storedmo.getWHManager(
                  pk_corp, null, cwarehouseid, cinvid));

            }
          }
        }

        // 分单
        resultVOs = (DelivConvertToOutHVO[]) nc.vo.scm.pub.vosplit.SplitBillVOs
            .getSplitVOs("nc.vo.dm.dm104.DelivConvertToOutHVO",
                "nc.vo.dm.dm104.DelivConvertToOutHHeaderVO",
                "nc.vo.dm.dm104.DelivConvertToOutHItemVO", vos, null,
                new String[] {
                    "vcustcode", "pkdeststockorg", "pkorder", "voutbilltype",
                    "pkstroe", "pkwhmanager"
                });
      }
      // 按仓库+单品分单
      else if (splitMode.equalsIgnoreCase("仓库+按单品")) {/*-=notranslate=-*/
        resultVOs = (DelivConvertToOutHVO[]) nc.vo.scm.pub.vosplit.SplitBillVOs
            .getSplitVOs("nc.vo.dm.dm104.DelivConvertToOutHVO",
                "nc.vo.dm.dm104.DelivConvertToOutHHeaderVO",
                "nc.vo.dm.dm104.DelivConvertToOutHItemVO", vos, null,
                new String[] {
                    "vcustcode", "pkdeststockorg", "pkorder", "voutbilltype",
                    "pkstroe", "pkinv"
                });
      }

      // 按仓库+存货大类分单
      else
      // if (splitMode.equalsIgnoreCase("仓库+存货大类"))
      {
        Vector vBaseids = new Vector();
        String cinvid = null;
        String[] cinvids = null;
        // 取得存货对应的存货大类
        for (int i = 0; i < vos.length; i++) {
          items = (DelivConvertToOutHItemVO[]) vos[i].getChildrenVO();
          for (int j = 0; j < items.length; j++) {
            cinvid = items[j].getAttributeValue("pkinv").toString();
            if (!vBaseids.contains(cinvid))
              vBaseids.addElement(cinvid);
          }
        }
        if (vBaseids.size() > 0) {
          cinvids = new String[vBaseids.size()];
          vBaseids.copyInto(cinvids);

          table = pubDmo
              .fetchArrayValue(
                  "bd_invbasdoc inner join bd_invmandoc on bd_invbasdoc.pk_invbasdoc=bd_invmandoc.pk_invbasdoc",
                  "pk_invcl", "bd_invmandoc.pk_invmandoc",
                  "bd_invmandoc.pk_invmandoc", cinvids);

          // 存货大类赋值
          for (int i = 0; i < vos.length; i++) {
            items = (DelivConvertToOutHItemVO[]) vos[i].getChildrenVO();
            for (int j = 0; j < items.length; j++) {
              cinvid = items[j].getAttributeValue("pkinv").toString();
              if (vBaseids.contains(cinvid))
                items[j].setAttributeValue("pkinvsort", (String) table
                    .get(cinvid));
            }
          }
        }
        resultVOs = (DelivConvertToOutHVO[]) nc.vo.scm.pub.vosplit.SplitBillVOs
            .getSplitVOs("nc.vo.dm.dm104.DelivConvertToOutHVO",
                "nc.vo.dm.dm104.DelivConvertToOutHHeaderVO",
                "nc.vo.dm.dm104.DelivConvertToOutHItemVO", vos, null,
                new String[] {
                    "vcustcode", "pkdeststockorg", "pkorder", "voutbilltype",
                    "pkstroe", "pkinvsort"
                });
      }

    }
    catch (Exception e) {
      e.printStackTrace(System.out);
      // if (e instanceof BusinessException) {
      // throw new BusinessException( e);
      // } else
      throw new BusinessException(
          nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40140408",
              "UPP40140408-000118")/* @res "发运单推式生成出库单，分单出错！" */, e);
      /** <needn't>需要如此实现。zxping 20050617 */
    }
    return resultVOs;
  }

  /**
   * 此处插入方法说明。 功能：进行时间戳校验 参数：vo 返回：void 例外： 日期：(2002-9-18 11:03:32)
   * 修改日期，修改人，修改原因，注释标志：
   * 
   * @return java.util.ArrayList
   * @exception nc.ui.bd.datainit.BusinessException
   *              异常说明。
   */
  protected void timeStampCheck(DelivbillHVO vo) throws BusinessException {
    DelivbillHHeaderVO header = (DelivbillHHeaderVO) vo.getParentVO();
    // 行校验（pk是否存在 & ts是否已被改变）
    String[] sPk = {
      header.getPrimaryKey()
    };
    String[] sTs = {
      header.getAttributeValue("ts").toString()
    };

    DelivbillHDMO dmo = null;
    Hashtable ht = null;
    try {
      dmo = new DelivbillHDMO();
      ht = dmo.checkRowExitOrChanged(sPk, sTs, "dm_delivbill_h",
          "pk_delivbill_h", "ts");
    }
    catch (Exception ex) {
      throw new BusinessException(ex);
    }

    Integer iCheck = new Integer(ht.get(sPk[0]).toString());
    if (iCheck.intValue() == nc.vo.dm.pub.DMOCheckTsStatus.IsNotExistThePK) {
      String[] value = new String[] {
        vo.getParentVO().getAttributeValue("vdelivbillcode").toString()
      };// ,null,value
      throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance()
          .getStrByID("40140408", "UPP40140408-000128", null, value)/*
                                                                     * @res
                                                                     * "单据号为：{0}
                                                                     * 的记录不存在！"
                                                                     */);
    }
    else if (iCheck.intValue() == nc.vo.dm.pub.DMOCheckTsStatus.IsNotTheSameTs) {
      String[] value = new String[] {
        vo.getParentVO().getAttributeValue("vdelivbillcode").toString()
      };// ,null,value
      throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance()
          .getStrByID("40140408", "UPP40140408-000129", null, value)/*
                                                                     * @res
                                                                     * "单据号为：{0}
                                                                     * 的记录已被修改！"
                                                                     */);
    }
  }

  /**
   * 用VO对象的属性值更新数据库。 创建日期：(2002-6-3)
   * 
   * @param delivbillH
   *          nc.vo.dm.dm104.DelivbillHVO
   * @exception BusinessException
   *              异常说明。
   */
  private ArrayList updateGeneral(DelivbillHVO delivbillH,
      DMDataVO[] writeBackItems, boolean isForOut, ClientLink clientLink)
      throws BusinessException {
    return updateGeneral(delivbillH, writeBackItems, isForOut, true, clientLink);
  }

  /**
   * 用VO对象的属性值更新数据库。 needLock 是否需要锁表。因为在保存出库单时，需要锁发运单的表， 那么在方法
   * saveOutDM()中进行锁表，不需要在此处锁表。 创建日期：(2002-6-3)
   * 
   * @param delivbillH
   *          nc.vo.dm.dm104.DelivbillHVO
   * @exception BusinessException
   *              异常说明。
   */
  private ArrayList updateGeneralForWriteBackOutNum(DelivbillHVO delivbillH,
      DMDataVO[] writeBackItems, boolean isForOut,
      boolean needWriteBackDailyPL, ClientLink clientLink)
      throws BusinessException {
    ArrayList resultlist;
    String sLockPk[] = null;

    try {
      DelivbillHDMO dmo = new DelivbillHDMO();

      // 新增保存前的上游单据时间戳校验
      checkSourceTsForNewAdd("vdayplancode", "pkdayplan", "sourcebillts",
          new String[] {
            "dm_delivdaypl"
          }, new String[] {
            "pk_delivdaypl"
          }, new String[] {
            "ts"
          }, delivbillH.getChildrenVO());

      // 删除方案
      dmo.dataStoreSave("dm_delivbill_h", "dm_delivbill_b", delivbillH,
          "pk_delivbill_h", "pk_delivbill_b", "pk_delivbill_h",
          "pkcorpforgenoid");
      resultlist = dmo.update(delivbillH, isForOut, clientLink);

      // 得到时间戳
      resultlist.add(dmo.queryTimeStamp("dm_delivbill_h", "pk_delivbill_h",
          delivbillH.getParentVO().getPrimaryKey().toString()));
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    finally {
      try {

        if (writeBackItems != null && needWriteBackDailyPL) {
          DeliverydailyplanImpl remote = new nc.impl.dm.dm102.DeliverydailyplanImpl();

          remote.setSendNum(writeBackItems);
        }
      }
      catch (Exception e) {
        reportException(e);
        if (e instanceof BusinessException)
          throw (BusinessException) e;
        else
          throw new BusinessException(e);
      }

    }
    return resultlist;
  }

  /**
   * 用VO对象的属性值更新数据库。 needLock 是否需要锁表。因为在保存出库单时，需要锁发运单的表， 那么在方法
   * saveOutDM()中进行锁表，不需要在此处锁表。 创建日期：(2002-6-3)
   * 
   * @param delivbillH
   *          nc.vo.dm.dm104.DelivbillHVO
   * @exception BusinessException
   *              异常说明。
   */
  private ArrayList updateGeneral(DelivbillHVO delivbillH,
      DMDataVO[] writeBackItems, boolean isForOut, boolean needLock,
      ClientLink clientLink) throws BusinessException {
    ArrayList resultlist;
    String sLockPk[] = null;

    try {
      DelivbillHDMO dmo = new DelivbillHDMO();

      if (needLock) {
        // 加锁
        sLockPk = dmo.getLockPKsArray(delivbillH, "pk_delivbill_h",
            "pk_delivbill_b", "pk_delivbill_h", new String[] {
              "pkdayplan"
            }, new String[0]);

        lockPKs(sLockPk, clientLink.getUser());

        // 调用校验方法
        saveCheck(delivbillH, clientLink);
      }

      // 新增保存前的上游单据时间戳校验
      checkSourceTsForNewAdd("vdayplancode", "pkdayplan", "sourcebillts",
          new String[] {
            "dm_delivdaypl"
          }, new String[] {
            "pk_delivdaypl"
          }, new String[] {
            "ts"
          }, delivbillH.getChildrenVO());

      // 对删除和修改行释放单据号
      returnBillCode(DMBillTypeConst.m_delivDelivBill, "pkcorpforgenoid",
          "vdelivbillcode", "voldDelivbillcode", new DelivbillHVO[] {
            delivbillH
          });

      // 删除方案
      dmo.dataStoreSave("dm_delivbill_h", "dm_delivbill_b", delivbillH,
          "pk_delivbill_h", "pk_delivbill_b", "pk_delivbill_h",
          "pkcorpforgenoid");
      resultlist = dmo.update(delivbillH, isForOut, clientLink);

      // 得到时间戳
      resultlist.add(dmo.queryTimeStamp("dm_delivbill_h", "pk_delivbill_h",
          delivbillH.getParentVO().getPrimaryKey().toString()));

      // 进行按钮注册
      // signButtonClickTime(RecordType.UPDATESAVESEND, delivbillH, false);

    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    finally {
      try {
        if (needLock) {
          // 解锁
          unLockPKs(sLockPk, clientLink.getUser());
        }

        if (writeBackItems != null) {
          DeliverydailyplanImpl remote = new nc.impl.dm.dm102.DeliverydailyplanImpl();

          remote.setSendNum(writeBackItems);
        }
      }
      catch (Exception e) {
        reportException(e);
        if (e instanceof BusinessException)
          throw (BusinessException) e;
        else
          throw new BusinessException(e);
      }

    }
    return resultlist;
  }

  /**
   * 用VO对象的属性值更新数据库。 创建日期：(2002-6-11)
   * 
   * @param delivbillH
   *          nc.vo.dm.dm106.DelivbillHVO
   * @exception BusinessException
   *              异常说明。
   */
  private ArrayList updateSignDeliv(DelivbillHVO delivbillH)
      throws BusinessException {
    ArrayList resultlist = null;
    
    IScm srv = (IScm) NCLocator.getInstance().lookup(IScm.class.getName());    
    srv.checkDefDataType(delivbillH);
    
    try {
      DelivbillHDMO dmo = new DelivbillHDMO();
      // 回写发运单
      resultlist = dmo.updateSign(delivbillH);
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    return resultlist;
  }

  /**
   * 正常的签收确认。 创建日期：(2002-6-11)
   * 
   * @param delivbillH
   *          nc.vo.dm.dm106.DelivbillHVO
   * @exception BusinessException
   *              异常说明。
   */
  public ArrayList updateSignDelivPlan(DelivbillHVO delivbillH,
      DMDataVO[] replandata, DMDataVO[] reOutbillData, ClientLink clientLink)
      throws BusinessException {
    return updateSignDelivPlan(delivbillH, replandata, reOutbillData, false,
        clientLink);
  }

  /**
   * 签收确认和取消签收。 创建日期：(2002-6-11)
   * 
   * @param delivbillH
   *          nc.vo.dm.dm106.DelivbillHVO
   * @exception BusinessException
   *              异常说明。
   */
  protected ArrayList updateSignDelivPlan(DelivbillHVO delivbillH,
      DMDataVO[] replandata, DMDataVO[] reOutbillData, boolean bIsCancelAll,
      ClientLink clientLink) throws BusinessException {
    String[] lockpks = null;
    ArrayList resultlist = null;
    try {
      IScm srv = (IScm) NCLocator.getInstance().lookup(IScm.class.getName());    
      srv.checkDefDataType(delivbillH);

      DelivbillHVO[] delivbillHs = new DelivbillHVO[1];
      delivbillHs[0] = delivbillH;
      DelivbillHItemVO[] items = (DelivbillHItemVO[]) delivbillH
          .getChildrenVO();

      // 加锁
      lockpks = new String[delivbillH.getChildrenVO().length + 1];
      for (int i = 0; i < delivbillH.getChildrenVO().length; i++) {
        lockpks[i] = items[i].getAttributeValue("pk_delivbill_b").toString();
      }
      lockpks[delivbillH.getChildrenVO().length] = delivbillH.getParentVO()
          .getPrimaryKey();
      lockPKs(lockpks, ((DelivbillHHeaderVO) delivbillH.getParentVO())
          .getAttributeValue("userid").toString());

      // 时间戳校验
      checkTs(delivbillHs);

      // 回写发运单
      resultlist = updateSignDeliv(delivbillH);
      // 回写日计划
      updateSignPlan(replandata);
      // 回写出库单
      if (!bIsCancelAll) {
        // 执行回写
        updateSignOutBill(reOutbillData);
      }
      else {
        // 执行出库单删除已签收数量
        // updateSignOutBill(reOutbillData);

        DMDataVO[] dmdvos = new DMDataVO[delivbillH.getChildrenVO().length];
        for (int i = 0; i < dmdvos.length; i++) {
          dmdvos[i] = new DMDataVO();
          dmdvos[i].setAttributeValue("pk_delivbill_h", delivbillH
              .getParentVO().getAttributeValue("pk_delivbill_h"));
          dmdvos[i].setAttributeValue("pk_delivbill_b", delivbillH
              .getChildrenVO()[i].getAttributeValue("pk_delivbill_b"));
          dmdvos[i].setAttributeValue("pkcorpforgenoid", delivbillH
              .getChildrenVO()[i].getAttributeValue("pkcorpforgenoid"));
        }
        cancelSignOutBill(dmdvos);

      }

      // 进行按钮注册
      signButtonClickTime(RecordType.SIGNSEND, delivbillH, false);

      // 自动终结发运单,依参数而定
      autoEndBillByPara(delivbillH.getParentVO().getAttributeValue(
          "pk_delivbill_h").toString(), delivbillH.getParentVO()
          .getAttributeValue("pkcorpforgenoid").toString(), clientLink);

    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    finally {
      // 解锁
      unLockPKs(lockpks, clientLink.getUser());
      // ((DelivbillHHeaderVO)
      // delivbillH.getParentVO()).getAttributeValue("userid").toString());
    }
    return resultlist;
  }

  /**
   * 签收确认时回写出库单。 创建日期：(2002-6-11)
   * 
   * @param delivbillH
   *          nc.vo.dm.dm106.DelivbillHVO
   * @exception BusinessException
   *              异常说明。
   */
  protected void updateSignOutBill(DMDataVO[] reOutbillData)
      throws BusinessException {
    // 回写出库单
    try {
      nc.bs.dm.pub.fromic.DmFromIcDMO dmo = new nc.bs.dm.pub.fromic.DmFromIcDMO();
      UFBoolean b = dmo.setOutSignNum(reOutbillData);
      if (!b.booleanValue()) {
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance()
            .getStrByID("40140408", "UPP40140408-000119")/* @res "出库单未找到！" */);
      }
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * 用VO对象的属性值更新数据库。 创建日期：(2002-6-11)
   * 
   * @param delivbillH
   *          nc.vo.dm.dm106.DelivbillHVO
   * @exception BusinessException
   *              异常说明。
   */
  private void updateSignPlan(DMDataVO[] replandata) throws BusinessException {
    // nc.bs.dm.dm102.Deliverydailyplan boDeliverydailyplan = null;
    try {
      // 回写日计划
      // nc.bs.dm.dm102.DeliverydailyplanHome home =
      // (nc.bs.dm.dm102.DeliverydailyplanHome)
      // getBeanHome(nc.bs.dm.dm102.DeliverydailyplanHome.class,
      // "nc.bs.dm.dm102.DeliverydailyplanBO");
      // boDeliverydailyplan = home.create();
      nc.impl.dm.dm102.DeliverydailyplanImpl boDeliverydailyplan = new nc.impl.dm.dm102.DeliverydailyplanImpl();
      boDeliverydailyplan.setSignAndBackNum(replandata);
      // boDeliverydailyplan.remove();
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    finally {
      // removeRemoteBO(boDeliverydailyplan);
    }
  }

  /**
   * 此处插入方法说明。 功能：如果如下两个条件都满足，则自动终结相应的发运单。 条件一：参数“签收完成是否自动关闭发运单”为“是”
   * 条件二：发运单（所有行）数量≤累计签收数量+累计途损数量+累计退回数量
   * 需要注意的是：在该方法中还完成一件事情，就是判断所有的发运单表体之前都处于非关闭状态
   * 
   * @param sDelivBillBodyPKs[]
   *          java.lang.String
   */
  public void autoCloseDelivBillByPara(String[] sDelivBillBodyPKs,
      String sCorpPK, ClientLink clientLink) throws BusinessException {
    try {
      if (sDelivBillBodyPKs == null || sDelivBillBodyPKs.length == 0)
        return;

      // 签收完成是否自动关闭发运单
      String sDM002 = getStringICPara(sCorpPK, "DM002");
      if (sDM002.equals("N")) {
        return;
      }

      /*
       * DelivbillHDMO dmo = new DelivbillHDMO(); //根据条件更新发运单表头的时间戳 StringBuffer
       * sbUpdateHead = new StringBuffer(); sbUpdateHead.append("update
       * dm_delivbill_h set dr=0 where pk_delivbill_h in ").append( " (select
       * distinct pk_delivbill_h from dm_delivbill_b ").append(" where
       * ").append( new DMDataVO().getStrPKs("pk_delivbill_b",
       * sDelivBillBodyPKs)).append(" and ").append( "doutnum-(isnull(dsignnum,
       * 0))-(isnull(dcancelnum, 0))-(isnull(dwaylossnum, 0)) <=0 ").append( ")
       * and dr=0 "); //更新时间戳 dmo.saveExecute(sbUpdateHead); //根据条件更新发运单表体的时间戳
       * StringBuffer sbUpdateBody = new StringBuffer();
       * sbUpdateBody.append("update dm_delivbill_b set irowstatus= " +
       * DelivBillStatus.End).append(" where ") .append(new
       * DMDataVO().getStrPKs("pk_delivbill_b", sDelivBillBodyPKs)).append(" and
       * ").append( "doutnum-(isnull(dsignnum, 0))-(isnull(dcancelnum,
       * 0))-(isnull(dwaylossnum, 0)) <=0 ").append( "and dr=0"); //执行关闭
       * dmo.saveExecute(sbUpdateBody);
       */

      // 判断所有的发运单表体之前都处于非关闭状态
      StringBuffer sb2 = new StringBuffer();
      sb2
          .append(
              "select head.vdelivbillcode from dm_delivbill_h head, dm_delivbill_b body ")
          .append(
              "where head.dr=0 and body.dr=0 and head.pk_delivbill_h=body.pk_delivbill_h and ")
          .append(
              new DMDataVO()
                  .getStrPKs("body.pk_delivbill_b", sDelivBillBodyPKs)).append(
              " and body.irowstatus=" + DelivBillStatus.End);
      DMDataVO[] closedDelivBill = super.query(sb2);
      if (closedDelivBill != null && closedDelivBill.length > 0) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < closedDelivBill.length; i++) {
          String sCode = (String) closedDelivBill[i]
              .getAttributeValue("vdelivbillcode");
          if (i != 0) {
            sb.append(", " + sCode);
          }
          else {
            sb.append(sCode);
          }
        }
        String[] value = new String[] {
          sb.toString()
        };//
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance()
            .getStrByID("40140408", "UPP40140408-000193", null, value)/*
                                                                       * @res
                                                                       * "单据号为：{0}
                                                                       * 的发运单已经关闭，不能再进行签收操作！"
                                                                       */);
      }

      // 发运单（所有行）数量≤累计签收数量+累计途损数量+累计退回数量，
      // 来得到需要关闭的发运单
      String itemWhere = new DMDataVO().getStrPKs(
          "dm_delivbill_b.pk_delivbill_b", sDelivBillBodyPKs)
          + " and  dm_delivbill_b.dinvnum-(isnull(dm_delivbill_b.dsignnum, 0))-(isnull(dm_delivbill_b.dcancelnum, 0))-(isnull(dm_delivbill_b.dwaylossnum, 0))<=0 "
          + " and dm_delivbill_b.dr=0 and dm_delivbill_b.irowstatus<>"
          + DelivBillStatus.End;

      String headWhere = " dm_delivbill_h.pk_delivbill_h in "
          + " (select distinct body.pk_delivbill_h from dm_delivbill_b body where "
          + new DMDataVO().getStrPKs("body.pk_delivbill_b", sDelivBillBodyPKs)
          + " and  body.dinvnum-(isnull(body.dsignnum, 0))-(isnull(body.dcancelnum, 0))-(isnull(body.dwaylossnum, 0))<=0 "
          + " and body.dr=0 and body.irowstatus<>" + DelivBillStatus.End + ") ";

      String pkdo = null;
      DelivbillHVO[] delivBills = findDelivBills(pkdo, headWhere, itemWhere);

      for (int i = 0; delivBills != null && i < delivBills.length; i++) {

        delivBills[i].setStatus(nc.vo.pub.VOStatus.UPDATED);

        DelivbillHItemVO[] items = (DelivbillHItemVO[]) delivBills[i]
            .getChildrenVO();

        // 只有在所有的表体行都出库结束并且签收的情况下，才能进行整单关闭
        StringBuffer sb = new StringBuffer();
        sb
            .append(" select 1 as valve from dm_delivbill_b where dr=0 ")
            .append(
                "and dinvnum-(isnull(dsignnum, 0))-(isnull(dcancelnum, 0))-(isnull(dwaylossnum, 0))>0 ")
            .append("and pk_delivbill_h='").append(
                ((DelivbillHHeaderVO) delivBills[i].getParentVO())
                    .getPk_delivbill_h()).append("'");
        DMDataVO[] testVO = super.query(sb);
        boolean bCloseWholeBill = false;// 整单关闭
        if (testVO == null || testVO.length == 0) {
          bCloseWholeBill = true;
        }

        for (int j = 0; j < items.length; j++) {
          if (bCloseWholeBill) {
            items[j].setBcloseout(new UFBoolean(true));// 是否已出库关闭
            items[j].setIrowstatus(new Integer(DelivBillStatus.End));// 行状态
          }

          items[j].setStatus(nc.vo.pub.VOStatus.UPDATED);
        }

        // 回写日计划的VO
        DMDataVO[] writeBackItems = DelivBillVOTool.getWriteBackBill(
            delivBills[i], (DelivbillHHeaderVO) delivBills[i].getParentVO(),
            items, clientLink); // 由修改前的单据和修改后的单据得到回写日计划的单据

        update(delivBills[i], writeBackItems, true, bCloseWholeBill, false,
            new UFBoolean(false), clientLink);
      }

    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * 此处插入方法说明。 功能：计算运费 参数： 返回： 例外： 日期：(2002-8-30 20:05:00) 修改日期，修改人，修改原因，注释标志：
   * 
   * @return nc.vo.dm.pub.DMDataVO
   * @param dmdvoForCalculate
   *          nc.vo.dm.pub.DMDataVO
   * @exception BusinessException
   *              异常说明。
   */
  public HashMap calculateTransFeeForTest(HashMap hmCustToCalculate)
      throws BusinessException {
    HashMap hmTranCustToCalculateReturn = new HashMap();
    try {
      String[] sTranCusts = (String[]) hmCustToCalculate.keySet().toArray(
          new String[0]);
      for (int i = 0; i < hmCustToCalculate.size(); i++) {
        nc.vo.dm.pub.DMDataVO dmdvoFeeItems = (DMDataVO) hmCustToCalculate
            .get(sTranCusts[i]);
        // 强制置成不同承运商
        DMVO dmvoTransBillVO = (DMVO) dmdvoFeeItems
            .getAttributeValue("transbill");
        dmvoTransBillVO.getHeaderVO().setAttributeValue("pktrancust",
            sTranCusts[i]);
        dmdvoFeeItems = calculateTransFee(dmdvoFeeItems);
        hmTranCustToCalculateReturn.put(sTranCusts[i], dmdvoFeeItems);
      }
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    return hmTranCustToCalculateReturn;
  }

  /**
   * 创建日期：(2003-11-5 19:45:00) 作者：仲瑞庆 参数： 返回： 说明：
   * 
   * @return java.util.ArrayList
   * @param delivbillH
   *          nc.vo.dm.dm104.DelivbillHVO
   */
  public ArrayList auditDelivbill(DelivbillHVO delivbillH, ClientLink clientLink)
      throws BusinessException {
    ArrayList resultlist = null;
    String sLockPk[] = null;
    String sUserID = null;
    try {
      DelivbillHDMO dmo = new DelivbillHDMO();
      // 加锁
      sLockPk = dmo.getLockPKsArray(delivbillH, "pk_delivbill_h",
          "pk_delivbill_b", "pk_delivbill_h", new String[] {
            "pkdayplan"
          }, new String[0]);
      // if (delivbillH.getParentVO().getAttributeValue("userid") != null)
      sUserID = sUserID = clientLink.getUser(); // delivbillH.getParentVO().getAttributeValue("userid").toString();
      lockPKs(sLockPk, sUserID);
      // 调用校验方法
      saveCheck(delivbillH, clientLink);

      // 新增保存前的上游单据时间戳校验
      checkSourceTsForNewAdd("vdayplancode", "pkdayplan", "sourcebillts",
          new String[] {
            "dm_delivdaypl"
          }, new String[] {
            "pk_delivdaypl"
          }, new String[] {
            "ts"
          }, delivbillH.getChildrenVO());

      // 删除方案
      dmo.dataStoreSave("dm_delivbill_h", "dm_delivbill_b", delivbillH,
          "pk_delivbill_h", "pk_delivbill_b", "pk_delivbill_h",
          "pkcorpforgenoid");
      resultlist = dmo.execAudit(delivbillH);

      // 得到时间戳
      // 如下一段代码为冗余代码 commented by zxping 20050301
      /*
       * resultlist.add( dmo.queryTimeStamp( "dm_delivbill_h", "pk_delivbill_h",
       * delivbillH.getParentVO().getPrimaryKey().toString()));
       */

      // 进行按钮注册
      // signButtonClickTime(RecordType.UPDATESAVESEND, delivbillH, false);
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    finally {
      try {
        // 解锁
        unLockPKs(sLockPk, sUserID);

        // 回写发运日计划
        /*
         * nc.bs.dm.dm102.DeliverydailyplanHome home =
         * (nc.bs.dm.dm102.DeliverydailyplanHome)
         * getBeanHome(nc.bs.dm.dm102.DeliverydailyplanHome.class,
         * "nc.bs.dm.dm102.DeliverydailyplanBO");
         * nc.bs.dm.dm102.Deliverydailyplan remote = home.create(); if (dmitems !=
         * null) remote.setSendNum(dmitems);
         */
      }
      catch (Exception e) {
        reportException(e);
        if (e instanceof BusinessException)
          throw (BusinessException) e;
        else
          throw new BusinessException(e);
      }
    }
    return resultlist;
  }

  /**
   * 创建日期：(2003-11-5 19:45:00) 作者：仲瑞庆 参数： 返回： 说明：
   * 
   * @return java.util.ArrayList
   * @param delivbillH
   *          nc.vo.dm.dm104.DelivbillHVO
   */
  public ArrayList auditAndGenDelivfee(DelivbillHVO delivbillH,
      nc.vo.dm.dm107.DelivfeebillHVO delivfeebillvo, ClientLink clientLink)
      throws BusinessException {
    ArrayList resultlist = null;
    String sLockPk[] = null;
    String sUserID = null;
    try {
      DelivbillHDMO dmo = new DelivbillHDMO();
      // 加锁
      sLockPk = dmo.getLockPKsArray(delivbillH, "pk_delivbill_h",
          "pk_delivbill_b", "pk_delivbill_h", new String[] {
            "pkdayplan"
          }, new String[0]);
      // if (delivbillH.getParentVO().getAttributeValue("userid") != null)
      sUserID = sUserID = clientLink.getUser(); // delivbillH.getParentVO().getAttributeValue("userid").toString();
      lockPKs(sLockPk, sUserID);
      // 调用校验方法
      saveCheck(delivbillH, clientLink);

      // 新增保存前的上游单据时间戳校验
      checkSourceTsForNewAdd("vdayplancode", "pkdayplan", "sourcebillts",
          new String[] {
            "dm_delivdaypl"
          }, new String[] {
            "pk_delivdaypl"
          }, new String[] {
            "ts"
          }, delivbillH.getChildrenVO());

      // 删除方案
      dmo.dataStoreSave("dm_delivbill_h", "dm_delivbill_b", delivbillH,
          "pk_delivbill_h", "pk_delivbill_b", "pk_delivbill_h",
          "pkcorpforgenoid");
      resultlist = dmo.execAudit(delivbillH);

      // 得到时间戳
      resultlist.add(dmo.queryTimeStamp("dm_delivbill_h", "pk_delivbill_h",
          delivbillH.getParentVO().getPrimaryKey().toString()));

      // -----------生成运费单
      // 0回写时间戳
      if (null != resultlist && resultlist.size() > 0) {
        if (delivbillH.getParentVO() != null) {
          delivbillH.getParentVO().setAttributeValue("ts",
              resultlist.get(resultlist.size() - 1));
        }
      }
      // 1解锁
      unLockPKs(sLockPk, sUserID);
      // 2调用生成运费单接口
      resultlist = saveDelivPackNumAndTransFeeVO(null, delivfeebillvo,
          delivbillH, clientLink);
      // 3加锁
      lockPKs(sLockPk, sUserID);

      // 进行按钮注册
      // signButtonClickTime(RecordType.UPDATESAVESEND, delivbillH, false);

    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    finally {
      try {
        // 解锁
        unLockPKs(sLockPk, sUserID);

        // 回写发运日计划
        /*
         * nc.bs.dm.dm102.DeliverydailyplanHome home =
         * (nc.bs.dm.dm102.DeliverydailyplanHome)
         * getBeanHome(nc.bs.dm.dm102.DeliverydailyplanHome.class,
         * "nc.bs.dm.dm102.DeliverydailyplanBO");
         * nc.bs.dm.dm102.Deliverydailyplan remote = home.create(); if (dmitems !=
         * null) remote.setSendNum(dmitems);
         */
      }
      catch (Exception e) {
        reportException(e);
        if (e instanceof BusinessException)
          throw (BusinessException) e;
        else
          throw new BusinessException(e);
      }
    }
    return resultlist;
  }

  // 判断该发运单的运费分摊依据 ：发运方式＋承运商＋计价依据唯一
  public Integer findAllotRuleByDelivBillCode(String sDelivBillPK,
      String sDelivOrgID, Integer iWholetruckAlloctRule)
      throws BusinessException, Exception {

    StringBuffer sb = new StringBuffer();
    sb.append("select dm_baseprice.ipricetype ")
    // 计价依据

        .append("from dm_delivbill_h deliv_h  ").append(
            "inner join dm_baseprice ON dm_baseprice.pkdelivorg='"
                + sDelivOrgID + "' ").append(
            "  and dm_baseprice.pk_transcust=deliv_h.pktrancust ").append(
            "  and dm_baseprice.pk_sendtype=deliv_h.pkdelivmode ").append(
            "  and dm_baseprice.dr=0 and deliv_h.dr=0 ")

        .append(
            "where deliv_h.pk_delivbill_h='" + sDelivBillPK
                + "' and deliv_h.pkdelivorg='" + sDelivOrgID + "' ");

    DMDataVO[] result = super.query(sb);
    if (result == null || result.length == 0)
      return iWholetruckAlloctRule;
    // throw new BusinessException( new Exception("发运单 "+sDelivBillCode+"
    // 没有对应的运费分摊依据！"));

    String s = result[0].getAttributeValue("ipricetype").toString();
    if (s.equals(ConstForBasePrice.IPriceType_Weight.toString())) {// 重量
      return new Integer(ConstAllotRule.iInvWeight);
    }
    else if (s.equals(ConstForBasePrice.IPriceType_PackNum.toString())) {// 件数，按体积处理
      return new Integer(ConstAllotRule.iInvVolumn);
    }
    else if (s.equals(ConstForBasePrice.IPriceType_WholeVehicle.toString())) {// 整车，根据参数得出
      return iWholetruckAlloctRule;
    }
    else if (s.equals(ConstForBasePrice.IPriceType_Num.toString())) {// 数量
      return new Integer(ConstAllotRule.iInvNum);
    }
    else if (s.equals(ConstForBasePrice.IPriceType_Volumn.toString())) {// 体积
      return new Integer(ConstAllotRule.iInvVolumn);
    }

    return iWholetruckAlloctRule;
    // throw new BusinessException( new Exception("发运单 "+sDelivBillPK+"
    // 缺少对应的运费分摊依据！"));

  }

  /**
   * 根据where子句查询单据。 功能： 参数： 返回： 例外： 日期：(2002-9-9 22:34:22) 修改日期，修改人，修改原因，注释标志：
   * 
   * @return nc.vo.dm.dm104.DelivbillHVO[]
   * @param currentdoname
   *          java.lang.String
   * @param pkdo
   *          java.lang.String
   * @param headWhere
   *          java.lang.String
   * @param itemWhere
   *          java.lang.String
   */
  public DelivbillHVO[] findDelivBillsWithStorOrgPower(String pkdo,
      String headWhere, String itemWhere, DMDataVO dmdvoSendStorOrg)
      throws BusinessException {
    DelivbillHVO[] bills = null;
    try {
      String[] sStorOrgs = (String[]) ((ArrayList) dmdvoSendStorOrg.getAttributeValue("agentcorpids")).toArray(new String[0]);
      //得到发货库存组织权限过滤
      nc.impl.dm.dm102.DeliverydailyplanImpl dataPowerBO = new nc.impl.dm.dm102.DeliverydailyplanImpl();
      String sSendStorOrgSql = dataPowerBO
          .deliverydailyplan_getDataPowerSubSql(
              "bd_calbody",
              "库存组织",
              //"dm_delivbill_b.pksendstockorg",
              "(case when dm_delivbill_b.vbilltype='21' and dm_delivbill_b.borderreturn='N' then dm_delivbill_b.pkdeststockorg else  dm_delivbill_b.pksendstockorg end) ",
              sStorOrgs, dmdvoSendStorOrg.getAttributeValue("userid").toString());
      if (sSendStorOrgSql != null && sSendStorOrgSql.trim().length() > 0) {
        if (itemWhere != null && itemWhere.trim().length() > 0) {
          itemWhere += " and " + sSendStorOrgSql;
        }
        else {
          itemWhere = sSendStorOrgSql;
        }
      }

      if (itemWhere == null || itemWhere.trim().length() == 0) {
        itemWhere = " 1=1 ";
      }

      bills = findDelivBills(pkdo, headWhere, itemWhere, new UFBoolean(false));
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    return bills;
  }

  /**
   * 根据where子句查询单据。 功能： 参数： 返回： 例外： 日期：(2002-9-9 22:34:22) 修改日期，修改人，修改原因，注释标志：
   * 
   * @return nc.vo.dm.dm104.DelivbillHVO[]
   * @param currentdoname
   *          java.lang.String
   * @param pkdo
   *          java.lang.String
   * @param headWhere
   *          java.lang.String
   * @param itemWhere
   *          java.lang.String
   */
  public DelivbillHVO[] findDelivBillsWithStorOrgPowerForSofee(String pkdo,
      String headWhere, String itemWhere, DMDataVO dmdvoSendStorOrg,
      UFBoolean ufbIsForSoFee) throws BusinessException {
    DelivbillHVO[] bills = null;
    Transaction transaction = new Transaction();
    String classname = DelivbillForSO.class.getName();;
    String methodname = "findDelivBillsWithStorOrgPowerForSofee";
    Class[] parameterTypes = new Class[]{String.class , String.class , 
        String.class , DMDataVO.class};
    Object[] value = new Object[4];
    value[0] = pkdo;
    value[1] = headWhere;
    value[2] = itemWhere;
    value[3] = dmdvoSendStorOrg;
    try {
      bills = ( DelivbillHVO[] ) transaction.newTransaction(classname, methodname
          ,parameterTypes, value );
    }
    catch (Exception ex) {
      ExceptionUtils.marsh(ex);
    }
    return bills;
  }

  /**
   * 创建者：仲瑞庆 功能：获得针对所传入VO的对象VO，以用于生成单据编码 参数： 返回： 例外： 日期：(2001-10-22 16:09:40)
   * 修改日期，修改人，修改原因，注释标志：
   * 
   * @return nc.vo.pub.billcodemanage.BillCodeObjVO
   * @param vo
   *          nc.vo.pub.AggregatedValueObject
   */
  private BillCodeObjValueVO getBillCodeObjVO(CircularlyAccessibleValueObject vo) {
    BillCodeObjValueVO bcovo = new BillCodeObjValueVO();
    String[] names = vo.getAttributeNames();
    String[] values = new String[names.length];
    for (int j = 0; j < names.length; j++) {
      values[j] = vo.getAttributeValue(names[j]) == null ? "" : vo
          .getAttributeValue(names[j]).toString();
      // 强制置入中文名称
      if (names[j].equals("pkcorp")) {

        names[j] = "公司"; /*-=notranslate=-*/
      }
      else if (names[j].equals("pkinv")) {
        names[j] = "存货"; /*-=notranslate=-*/
      }
    }
    bcovo.setAttributeValue(names, values);
    return bcovo;
  }

  /**
   * 此处插入方法说明。 功能：依费用构成项属性查得值, 其中可能会自动填写费用项值到发运单VO中 参数： 返回： 例外： 日期：(2002-9-2
   * 19:47:48) 修改日期，修改人，修改原因，注释标志：
   * 
   * @param sClassName
   *          java.lang.String
   * @param sClassMethod
   *          java.lang.String
   * @param dmvoTransBill
   *          nc.vo.dm.pub.DMVO
   * @exception BusinessException
   *              异常说明。
   */
  private Object getFeeConItemValue(String sClassName, String sClassMethod,
      DMVO dmvoTransBill, UFDouble[] ufdRowFeeConItemValue,
      boolean bNeedCalculateToRow) throws BusinessException {
    try {
      Object obj = invokeMethodRun(sClassName, sClassMethod, new Class[] {
          DMVO.class, UFDouble[].class, Boolean.class
      }, new Object[] {
          dmvoTransBill, ufdRowFeeConItemValue,
          new Boolean(bNeedCalculateToRow)
      });
      if (null != obj)
        return obj;
      else
        return new UFDouble(0);
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * 向数据库中插入一个VO对象。 创建日期：(2002-6-3)
   * 
   * @param delivbillH
   *          nc.vo.dm.dm104.DelivbillHVO 发运单vo
   * @param writeBackItems
   *          DMDataVO[] 更新日计划的数据
   * @return java.lang.String 所插入VO对象的主键字符串。
   * @exception BusinessException
   *              异常说明。
   */
  public ArrayList insertDelivAndPackage(DelivbillHVO delivbillH,
      DMDataVO[] writeBackItems, DMDataVO[] dmdPackitems, ClientLink clientLink)
      throws BusinessException {
    
    IScm srv = (IScm) NCLocator.getInstance().lookup(IScm.class.getName());    
    srv.checkDefDataType(delivbillH);
    // 生成发运单
    ArrayList alresult = insert(delivbillH, writeBackItems, clientLink);
    
    
    // 整理包装单
    if (dmdPackitems != null) {
      for (int i = 0; i < dmdPackitems.length; i++) {
        dmdPackitems[i].setAttributeValue("pk_delivbill_h", alresult.get(0)
            .toString());
      }
      // 保存包装单
      saveDelivPackNum(dmdPackitems);
    }
    return alresult;
  }

  /**
   * 创建日期：(2004-3-24 11:27:06) 作者：仲瑞庆 参数：java.lang.String strDelivbillPks
   * 发运单pks，形如 <code>'121232321','23453534','214324234'</code> 的形式 返回：
   * 说明：根据发运单的 pks 查出对应的日计划 pks
   * 
   * @return java.util.ArrayList
   */
  private Hashtable queryDailyplanPKsByDelivbillPks(String strDelivbillPks)
      throws Exception {
    // StringBuffer sb = new StringBuffer();
    // sb
    // .append("select pkdayplan, pk_delivbill_b from dm_delivbill_b ")
    // .append("where pk_delivbill_b in (")
    // .append(strDelivbillPks)
    // .append(")");
    //
    // DMDataVO[] vo;
    // try {
    // vo = super.query(sb);
    // }
    // catch (Exception e) {
    // throw e;
    // }

    SmartDMO smartDMO = null;
    try {
      smartDMO = new SmartDMO();
    }
    catch (Exception e) {
      throw new SQLException(e.getMessage());
    }
    String strWhere = "pk_delivbill_b in (" + strDelivbillPks + ")";
    SmartVO[] vo = smartDMO.selectBy(nc.vo.dm.dm104.DelivbillHItemVO.class,
        new String[] {
            "pkdayplan", "pk_delivbill_b"
        }, strWhere);

    if (vo != null) {
      Hashtable htDailyPlanPks = new Hashtable();
      for (int i = vo.length - 1; i >= 0; i--) {
        htDailyPlanPks.put(
            vo[i].getAttributeValue("pk_delivbill_b").toString(), vo[i]
                .getAttributeValue("pkdayplan"));
      }
      return htDailyPlanPks;
    }

    return null;
  }

  /**
   * 此处插入方法说明。 功能：查询发运方式对应的费用项 参数： 返回： 例外： 日期：(2002-8-29 16:33:39)
   * 修改日期，修改人，修改原因，注释标志：
   * 
   * @return nc.vo.dm.pub.DMDataVO
   * @param sWhereClause
   *          java.lang.String
   * @exception BusinessException
   *              异常说明。
   */
  public nc.vo.dm.pub.DMDataVO[] queryDelivPackNum(String sWhereClause)
      throws BusinessException {
    try {
      DelivbillHDMO dmo = new DelivbillHDMO();
      return dmo.queryDelivPackNum(sWhereClause);
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * 此处插入方法说明。 功能：单价和最远里程 参数： 返回： 例外： 日期：(2002-8-29 16:33:39)
   * 修改日期，修改人，修改原因，注释标志：
   * 
   * @return nc.vo.dm.pub.DMDataVO
   * @param sWhereClause
   *          java.lang.String
   * @exception BusinessException
   *              异常说明。
   */
  public ArrayList getMaxmileAndPriceForPrint(DelivbillHVO[] delivVOs)
      throws BusinessException {
    try {
      ArrayList alRe = new ArrayList();
      nc.bs.dm.dm004.BasepriceDMO dmo = new nc.bs.dm.dm004.BasepriceDMO();
      DMVO dmvo = new DMVO();
      for (int i = 0; i < delivVOs.length; i++) {
        dmvo.translateFromOtherVO(delivVOs[i]);
        DMDataVO dmdRe = dmo.getMaxmileAndPriceForPrint(dmvo, null,
            new Boolean(false));
        alRe.add(i, dmdRe);
      }
      return alRe;
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * 创建日期：(2003-11-26 19:20:34) 作者：仲瑞庆 参数： 返回： 说明：
   * 
   * @param sBillTypeCodeKey
   *          java.lang.String
   * @param sCorpKey
   *          java.lang.String
   * @param sBillCodeKey
   *          java.lang.String
   * @param vos
   *          nc.vo.pub.AggregatedValueObject[]
   * @exception BusinessException
   *              异常说明。
   */
  private void returnBillCode(String sBillTypeCodeKey, String sCorpKey,
      String sBillCodeKey, String sOldBillCodeKey, AggregatedValueObject[] vos)
      throws BusinessException {
    try {
      String sOldBillCode = null;
      if (vos == null || vos.length == 0)
        return;
      DelivbillHDMO dmo = new DelivbillHDMO();
      BillCodeObjValueVO[] bvos = new BillCodeObjValueVO[vos.length];
      AggregatedValueObject[] vosNew = new AggregatedValueObject[vos.length];
      for (int i = 0; i < vos.length; i++) {
        vosNew[i] = (AggregatedValueObject) vos[i].getClass().newInstance();
        vosNew[i].setParentVO((CircularlyAccessibleValueObject) vos[i]
            .getParentVO().clone());
        vosNew[i].getParentVO().setAttributeValue("curbilltype",
            DMBillTypeConst.m_delivDelivBill);
        vos[i].getParentVO().setAttributeValue("curbilltype",
            DMBillTypeConst.m_delivDelivBill);
        bvos[i] = getBillCodeObjVO(vos[i].getParentVO());
        sOldBillCode = (String) vos[i].getParentVO().getAttributeValue(
            sOldBillCodeKey);
        if (vos[i].getParentVO().getStatus() != VOStatus.DELETED
            && sOldBillCode != null
            && !sOldBillCode.equals((String) vos[i].getParentVO()
                .getAttributeValue(sBillCodeKey))) {
          // 应该退旧号
          vosNew[i].getParentVO().setStatus(VOStatus.DELETED);
          vosNew[i].getParentVO().setAttributeValue(sBillCodeKey, sOldBillCode);
        }
      }
      dmo.returnAVOBillCode(sBillTypeCodeKey, sCorpKey, sBillCodeKey, bvos,
          vosNew);
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }

  }

  /**
   * 创建日期：(2003-11-26 19:20:15) 作者：仲瑞庆 参数： 返回： 说明：界面点取消时释放单据号
   * 
   * @param sBillTypeCodeKey
   *          java.lang.String
   * @param sCorpKey
   *          java.lang.String
   * @param sBillCodeKey
   *          java.lang.String
   * @param vos
   *          nc.vo.pub.AggregatedValueObject[]
   * @exception BusinessException
   *              异常说明。
   */
  public void delivbill_returnBillCodeForUI(String sCorpKey,
      String sBillCodeKey, AggregatedValueObject[] vos)
      throws BusinessException {
    try {
      if (vos == null || vos.length == 0)
        return;
      DelivbillHDMO dmo = new DelivbillHDMO();
      BillCodeObjValueVO[] bvos = new BillCodeObjValueVO[vos.length];
      for (int i = 0; i < vos.length; i++) {
        // bvos[i].setAttributeValue(sBillTypeCodeKey,
        // DMBillTypeConst.m_delivDelivBill);
        bvos[i] = getBillCodeObjVO(vos[i].getParentVO());
      }
      dmo.returnAVOBillCodeForUI2(sCorpKey, sBillCodeKey, bvos, vos);
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }

  }

  /**
   * 如果是删除签收单回写发运单，则发运单不能为关闭状态
   * 
   * @param vos
   *          DMDataVO[]
   * @throws BusinessException
   */
  public void checkDelivBillStatus(DMDataVO[] vos) throws BusinessException {
    int length = vos.length;
    if (length == 0) {
      return;
    }
    String[] ids = new String[length];
    for (int i = 0; i < length; i++) {
      ids[i] = (String) vos[i].getAttributeValue("pk_delivbill_b");
    }
    StringBuffer sql = new StringBuffer();
    sql.append(" select distinct vdelivbillcode from dm_delivbill_h a , ");
    sql.append(" dm_delivbill_b b where a.pk_delivbill_h= b.pk_delivbill_h ");
    sql.append(" and pk_delivbill_b in ( ");
    for (int i = 0; i < length; i++) {
      sql.append("'");
      sql.append(ids[i]);
      sql.append("',");
    }
    sql.deleteCharAt(sql.length() - 1);
    sql.append(") and irowstatus=3");
    DmImpl bo = new DmImpl();
    DMDataVO[] data = bo.queryStringBuffer(sql);
    if (data.length > 0) {
      StringBuffer billcode = new StringBuffer();
      for (int i = 0; i < data.length; i++) {
        billcode.append(data[i].getAttributeValue("vdelivbillcode"));
        billcode.append(",");
      }
      billcode.deleteCharAt(billcode.length() - 1);
      String[] args = new String[1];
      args[0] = billcode.toString();
      String message = nc.bs.ml.NCLangResOnserver.getInstance().getStrByID(
          "40140408", "UPP40140408-000198", null, args);
      /* @res "发运单{0}已经关闭，不能删除签收单" */
      throw new BusinessException(message);
    }
  }

  /**
   * 创建日期：(2004-3-17 15:04:39) 作者：zxping 参数： 返回： 说明：回写签收的接口。其中的字段 dsignnum 和
   * dreturnbacknum 存储的是差值
   * 
   * @param vo
   *          nc.vo.dm.pub.DMDataVO[] 签收单表体
   * @param boolean
   *          isWriteBackOutBill 是否需要回写出库单
   * @param boolean
   *          isSignFromDelivBill 是为发运单签收
   */
  public void setSignNum(DMDataVO[] vos, boolean isWriteBackOutBill,
      boolean isSignFromDelivBill) throws BusinessException {
    if (vos == null || vos.length == 0) {
      return;
    }

    if (!isSignFromDelivBill) {
      for (int i = 0; i < vos.length; i++) {
        vos[i].setAttributeValue("pk_sourcebill_b", vos[i]
            .getAttributeValue("pk_delivbill_b"));
      }
    }
    else {
      // 发运单不能为关闭状态
      checkDelivBillStatus(vos);

      for (int i = 0; i < vos.length; i++) {
        vos[i].setAttributeValue("pk_delivbill_h", vos[i]
            .getAttributeValue("pk_sourcebill_h"));// 为回写出库单做准备
        vos[i].setAttributeValue("pk_delivbill_b", vos[i]
            .getAttributeValue("pk_sourcebill_b"));// 为回写出库单做准备
        // vos[i].setAttributeValue("vbilltype",
        // vos[i].getAttributeValue("pk_sourcebilltype"));//为回写出库单做准备?
      }
    }

    try {
      // 置累加字段
      ValueRangeHashtableDelivbillBody htRangeBody = new ValueRangeHashtableDelivbillBody();
      ValueRange v1 = (ValueRange) htRangeBody.get("dsignnum");
      v1.setIsProgressive(true);
      htRangeBody.putValueRange(v1);

      v1 = (ValueRange) htRangeBody.get("dcancelnum");
      v1.setIsProgressive(true);
      htRangeBody.putValueRange(v1);

      // 重置发运单数据
      String str = null;
      Object obj;
      HashSet hs = new HashSet();// 发运单表头pk
      DMDataVO[] dmdvos = new DMDataVO[vos.length];
      for (int i = 0; i < vos.length; i++) {
        dmdvos[i] = new DMDataVO();

        dmdvos[i].setAttributeValue("dsignnum", vos[i]
            .getAttributeValue("dsignnum"));
        dmdvos[i].setAttributeValue("dcancelnum", vos[i]
            .getAttributeValue("dreturnbacknum"));

        dmdvos[i].setAttributeValue("pk_delivbill_b", vos[i]
            .getAttributeValue("pk_sourcebill_b"));

        dmdvos[i].setAttributeValue("receivedate", vos[i]
            .getAttributeValue("arrivedate"));// 到货日期

        dmdvos[i].setAttributeValue("pkcorp", vos[i]
            .getAttributeValue("pk_corp"));

        dmdvos[i].setStatus(VOStatus.UPDATED);

        vos[i].setAttributeValue("nsignnum", vos[i]
            .getAttributeValue("dsignnum")); // 为回写出库单做准备
        // vos[i].setAttributeValue("nbacknum",
        // vos[i].getAttributeValue("dreturnbacknum"));//为回写出库单做准备
        vos[i].setAttributeValue("pkcorpforgenoid", vos[i]
            .getAttributeValue("pk_corp")); // 为回写出库单做准备

        hs.add(vos[i].getAttributeValue("pk_delivbill_h").toString());
      }

      // 回写发运单
      DMVO vo = new DMVO();
      vo.setChildrenVO(dmdvos);

      vo = super.save(null, "dm_delivbill_b", vo, null, htRangeBody, false);

      // 更新发运单表头ts
      if (hs.size() > 0) {
        String[] sDelivBillHeadPKs = (String[]) hs
            .toArray(new String[hs.size()]);
        DelivbillHDMO delivDmo = new DelivbillHDMO();
        delivDmo.updateDelivbillHeadTs(sDelivBillHeadPKs);
      }

      // begin回写出库单
      if (isWriteBackOutBill) {
        // 回写出库单时，只需要传入发运单的表头表体ID和差额数量，以及公司主键
        nc.bs.dm.pub.fromic.DmFromIcDMO dmo = new nc.bs.dm.pub.fromic.DmFromIcDMO();
        UFBoolean b = dmo.setOutSignNum(vos);
        if (!b.booleanValue()) {
          throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance()
              .getStrByID("40140408", "UPP40140408-000119")/* @res "出库单未找到！" */);
        }
      }
      // end回写出库单

      // 重置日计划数据
      DMDataVO[] replandata = new DMDataVO[vos.length];
      for (int i = 0; i < vos.length; i++) {
        replandata[i] = new DMDataVO();
        replandata[i].setStatus(VOStatus.UPDATED);
        replandata[i].setAttributeValue("nsignnum", dmdvos[i]
            .getAttributeValue("dsignnum"));// 差值
        replandata[i].setAttributeValue("nbacknum", dmdvos[i]
            .getAttributeValue("dcancelnum"));// 差值

        replandata[i].setAttributeValue("pkbillh", vos[i]
            .getAttributeValue("pk_rootbill_h"));
        replandata[i].setAttributeValue("pkbillb", vos[i]
            .getAttributeValue("pk_rootbill_b"));
        replandata[i].setAttributeValue("vbilltype", vos[i]
            .getAttributeValue("pk_rootbilltype"));

        replandata[i].setAttributeValue("pk_delivdaypl", vos[i]
            .getAttributeValue("pkdayplan"));
        replandata[i].setAttributeValue("pksalecorp", vos[i]
            .getAttributeValue("pksalecorp"));
      }

      // 回写日计划
      nc.impl.dm.dm102.DeliverydailyplanImpl boDeliverydailyplan = new nc.impl.dm.dm102.DeliverydailyplanImpl();
      boDeliverydailyplan.setSignAndBackNum(replandata);

    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * 创建日期：(2004-3-17 15:04:39) 作者：zxping 参数： 返回： 说明：回写途损的接口
   * 
   * @param vo
   *          nc.vo.dm.pub.DMDataVO[] 途损单表体
   */
  public void setWayLossNum_delivbill(DMDataVO[] dmdatavo)
      throws BusinessException {
    if (dmdatavo == null || dmdatavo.length == 0) {
      return;
    }

    DMVO vo = new DMVO(dmdatavo.length);
    vo.setStatusTo(VOStatus.UPDATED);
    vo.getParentVO().setAttributeValue("pk_delivbill_h",
        dmdatavo[0].getAttributeValue("pk_delivbill_h"));

    // 设置字段 pkdelivorg 的值，仅仅作为产生 oid 之用，实际并不会保存到数据库中
    vo.getParentVO().setAttributeValue("pkcorp",
        dmdatavo[0].getAttributeValue("pkcorp"));
    HashSet hs = new HashSet();// 发运单表头pk
    Hashtable htDelivBillBodyPKs = new Hashtable(); //
    for (int i = 0; i < dmdatavo.length; i++) {
      String s = dmdatavo[i].getAttributeValue("pk_delivbill_b").toString();
      hs.add(dmdatavo[i].getAttributeValue("pk_delivbill_h").toString());
      htDelivBillBodyPKs.put(s, s);

      (vo.getChildrenVO())[i].setAttributeValue("vbilltype", dmdatavo[i]
          .getAttributeValue("vbilltype"));
      (vo.getChildrenVO())[i].setStatus(VOStatus.UPDATED); // it is important

      (vo.getChildrenVO())[i].setAttributeValue("dwaylossnum", dmdatavo[i]
          .getAttributeValue("dwaylossnum"));

      (vo.getChildrenVO())[i].setAttributeValue("pk_delivbill_b", s);

      // 设置字段 pkcorp 的值，仅仅作为产生 oid 之用，实际并不会保存到数据库中
      (vo.getChildrenVO())[i].setAttributeValue("pkcorp", dmdatavo[i]
          .getAttributeValue("pkcorp"));
    }

    // nc.bs.dm.dm102.Deliverydailyplan remote = null;

    try {
      // 确保途损数量在正确范围之内（较验）
      //String sVerifyResult = verifyWayLossNum(htDelivBillBodyPKs);
      //if (sVerifyResult != null && sVerifyResult.length() > 0) { // 存在不合法的回写途损数量
      //  throw new BusinessException(sVerifyResult);
      //}
      super.save(
      // "dm_delivbill_h",
          null, "dm_delivbill_b", vo, new ValueRangeHashtableDelivbillHeader(),
          new ValueRangeHashtableDelivbillBody(), true);

      // 更新发运单表头ts
      if (hs.size() > 0) {
        String[] sDelivBillHeadPKs = (String[]) hs
            .toArray(new String[hs.size()]);
        DelivbillHDMO delivDmo = new DelivbillHDMO();
        delivDmo.updateDelivbillHeadTs(sDelivBillHeadPKs);
      }
    }
    catch (Exception e) {
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    finally {
    }
  }

  // /**
  // * 创建日期：(2006-04-05 15:04:39) 作者：zlq 参数： 返回： 说明：回写发运日计划途损数量的接口
  // *
  // * @param vo
  // * nc.vo.dm.pub.DMDataVO[] 途损单表体
  // */
  // public void setWayLossNum_deliverydaily(DMDataVO[] dmdatavo) throws
  // BusinessException {
  // if (dmdatavo == null || dmdatavo.length == 0) {
  // return;
  // }
  // Hashtable htDelivBillBodyPKs = new Hashtable();
  // for (int i = 0; i < dmdatavo.length; i++) {
  // String s = dmdatavo[i].getAttributeValue("pk_delivbill_b").toString();
  // htDelivBillBodyPKs.put(s, s);
  // }
  // try{
  // //确保途损数量在正确范围之内（较验）
  // String sVerifyResult = verifyWayLossNum(htDelivBillBodyPKs);
  // if (sVerifyResult != null && sVerifyResult.length() > 0) { //存在不合法的回写途损数量
  // throw new BusinessException(sVerifyResult);
  // }
  // //回写日计划部分
  // //计算出需要查询日计划 pks 的发运单 pks
  // StringBuffer sb = new StringBuffer();
  // Iterator iterator = htDelivBillBodyPKs.values().iterator();
  // while (iterator.hasNext()) {
  // if (sb.length() > 0) {
  // sb.append(",'" + iterator.next().toString() + "'");
  // } else {
  // sb.append("'" + iterator.next().toString() + "'");
  // }
  // }
  // //将日计划的 pks 加入到 dmdatavo 中
  // Hashtable htDailyplanPKs = queryDailyplanPKsByDelivbillPks(sb.toString());
  // for (int i = 0; i < dmdatavo.length; i++) {
  // String s = dmdatavo[i].getAttributeValue("pk_delivbill_b").toString();
  // dmdatavo[i].setAttributeValue("pk_delivdaypl", htDailyplanPKs.get(s));
  // }
  // nc.impl.dm.dm102.DeliverydailyplanImpl remote = new
  // nc.impl.dm.dm102.DeliverydailyplanImpl();
  // remote.deliverydaily_setWayLossNum(dmdatavo);
  // } catch (Exception e) {
  // if (e instanceof BusinessException)
  // throw (BusinessException) e;
  // else
  // throw new BusinessException(e);
  // } finally {
  // }
  // }
  /**
   * @param delivbill
   * @param clientLink
   * @return
   * @throws BusinessException
   */
  public ArrayList closeOrOpenRowOut(DelivbillHVO delivbill,
      ClientLink clientLink) throws BusinessException {

    DelivbillHItemVO[] items = (DelivbillHItemVO[]) delivbill.getChildrenVO();
    DelivbillHHeaderVO header = (DelivbillHHeaderVO) delivbill.getParentVO();

    boolean isEnd = false; // 判断是否关闭操作

    // 发运单行出库关闭
    if (StringTools.getSimilarBoolean(items[0].getBcloseout())) {
      isEnd = true;
    }
    checkDelivbillTs(header.getPk_delivbill_h(), header.getTs().toString());

    // 回写日计划的VO
    // 由修改前的单据和修改后的单据得到回写日计划的单据
    // 当发运参数 DM018(发运单手工关闭时按执行数回写数量)为"Y",并且发运出库串行时,手工关闭或者打开发运单,需要作回写数量的特殊处理
    // @see DelivbillHBO#update(DelivbillHVO delivbill, DMDataVO[]
    // writeBackItems, boolean isModifyATP,
    // boolean isEnd, boolean isOpen, ClientLink clientLink)
    DMDataVO[] writeBackItems = DelivBillVOTool.getWriteBackBill(delivbill,
        header, items, clientLink);

    // return update(delivbill, writeBackItems, isModifyATP, isEnd, isOpen,
    // UFBoolean isRowEndOrOpenOP, clientLink);
    return update(delivbill, writeBackItems, true, isEnd, !isEnd,
        new UFBoolean(true), clientLink);
  }

  /**
   * 用VO对象的属性值更新数据库。 创建日期：(2002-6-3)
   * 
   * @param delivbill
   *          nc.vo.dm.dm104.DelivbillHVO
   * @exception BusinessException
   *              异常说明。
   */
  public ArrayList updateDelivbill(DelivbillHVO delivbill,
      DMDataVO[] writeBackItems, boolean isModifyATP, ClientLink clientLink)
      throws BusinessException {

    DelivbillHHeaderVO header = null;
    DelivbillHItemVO[] items = null;

    boolean isEnd = false; // 判断是否关闭操作

    if (delivbill != null) {
      items = (DelivbillHItemVO[]) delivbill.getChildrenVO();
      header = (DelivbillHHeaderVO) delivbill.getParentVO();
    }

    // 整单关闭的情况
    if (items != null && items.length > 0 && items[0] != null
        && items[0].getIrowstatus() != null
        && items[0].getIrowstatus().intValue() == DelivBillStatus.End) {
      isEnd = true;
    }

    // 判断是否打开操作
    boolean isOpen = false;
    if (header.getBisopen() != null) {
      isOpen = header.getBisopen().booleanValue();
    }

    // 发运单打开/关闭
    if (isOpen || isEnd) {
      String ts = header.getTs().toString();
      String billid = header.getPk_delivbill_h();
      checkDelivbillTs(billid, ts);
    }

    return update(delivbill, writeBackItems, isModifyATP, isEnd, isOpen,
        new UFBoolean(false), clientLink);
  }

  /**
   * 模仿自由状态的单据修改保存 NOTE:传入的发运单必定为 串行 情况 模仿时的情形： 打开时模仿, 关闭时模仿, 销售出库单回写发运单
   * 创建日期：(2002-5-17 14:27:23)
   * 
   * @param items
   *          nc.vo.dm.pub.DMDataVO[]
   */
  private void simulateModifyFreeDelivBill(DelivbillHVO delivbill)
      throws BusinessException {
    try {

      DelivbillHItemVO[] items = (DelivbillHItemVO[]) delivbill.getChildrenVO();

      // 处理回写上游数量
      ArrayList alDelivBillVOs = new ArrayList();

      for (int i = 0; i < items.length; i++) {
        if (items[i].getAttributeValue("vbilltype").equals("30")) {
          alDelivBillVOs.add(items[i]);
        }
      }

      if (alDelivBillVOs.size() > 0) {
        ArrayList alItemStatus = new ArrayList();
        // 模拟修改保存Atp影响
        DelivbillHItemVO[] items30 = (DelivbillHItemVO[]) alDelivBillVOs
            .toArray(new DelivbillHItemVO[0]);
        for (int i = 0; i < items30.length; i++) {
          alItemStatus.add(items30[i].getIrowstatus());
          items30[i].setIrowstatus(new Integer(DelivBillStatus.Free));
        }

        DelivbillHVO dvo = new DelivbillHVO();
        dvo.setParentVO(delivbill.getParentVO());
        dvo.setChildrenVO(items30);

        DLATP dmatp = new DLATP();
        dmatp.modifyATP(dvo);

        // 恢复正确的表体行状态
        for (int i = 0; i < items30.length; i++) {
          items30[i].setIrowstatus((Integer) alItemStatus.get(i));
        }
      }
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
  }

  /**
   * @param sDelivOrgPK
   * @param sParaCode
   * @return
   * @throws Exception
   */
  private DMDataVO getDelivOrgPara(String sDelivOrgPK, String sParaCode)
      throws Exception {
    // DM018：发运单关闭是否释放回写数量参数
    Hashtable htDelivOrgvo = new Hashtable();
    Hashtable htdeliv = new Hashtable();
    htdeliv.put(sDelivOrgPK, "");
    DeliverydailyplanImpl remote = new DeliverydailyplanImpl();
    htDelivOrgvo = remote.queryDelivOrgsHtvo(htdeliv, sParaCode);

    boolean bNeedTuneWriteBackItems = false;// 回写日计划的数量，根据参数 DM018
    // 和发运出库顺序的值，进行改动

    return (DMDataVO) htDelivOrgvo.get(sDelivOrgPK);
  }

  /**
   * //发运日计划关闭、发运单行出库关闭，分串行、并行两种模式： //? 串行模式：发运日计划关闭，按下游发运单行数量改写日计划【回写上游数量】为A， //
   * 同时调用回写上游规则，改写上游销售订单、调拨订单或采购订单的已发运数量为A； //
   * 发运单行出库关闭，按下游出库单行实发数量改写发运单【回写上游数量】为A， // 同时调用回写上游规则，改写上游发运日计划的已发运数量为A。 //?
   * 并行模式：由于发运单不影响ATP, 发运日计划关闭， // 无论有无发运单，都按下游出库单行签字数量改写发运日计划【回写上游数量】为A， //
   * 同时调用回写上游规则，改写上游销售订单、调拨订单或采购订单的已发运数量为A； // 发运单行出库关闭，由于下游无出库动作，没有回写影响。 NOITE:
   * when isRowEndOrOpenOP.booleanValue()==true, either para isEnd or isOpen
   * must be true. DM016 和 DM018 都只对来源于销售的发运单的可用量产生影响
   * 
   * @param delivbill
   * @param writeBackItems
   * @param isModifyATP
   * @param isEnd
   *          关闭操作
   * @param isOpen
   *          打开操作
   * @param isRowEndOrOpenOP
   *          是否是行出库关闭或者行出库打开操作
   * @param clientLink
   * @return
   * @throws BusinessException
   */
  private ArrayList update(DelivbillHVO delivbill, DMDataVO[] writeBackItems,
      boolean isModifyATP, boolean isEnd, boolean isOpen,
      UFBoolean isRowEndOrOpenOP, // 是否是行出库关闭或者行出库打开操作
      ClientLink clientLink) throws BusinessException {

    if (delivbill == null)
      return null;
    
    IScm srv = (IScm) NCLocator.getInstance().lookup(IScm.class.getName());    
    srv.checkDefDataType(delivbill);
    
    DelivbillHItemVO[] items = (DelivbillHItemVO[]) delivbill.getChildrenVO();
    DelivbillHHeaderVO header = (DelivbillHHeaderVO) delivbill.getParentVO();

    ArrayList resultlist = null;

    boolean isSigned = true;
    boolean isMustSign = false;
    try {
      timeStampCheck(delivbill); // 由于发运单节点和发运安排节点可以对同一张发运单进行交叉操作，可能导致不一致的情况。需要尽早进行判断，否则如下的一些操作可能出错。

      DMDataVO delivOrgParaVO = getDelivOrgPara(((DelivbillHHeaderVO) delivbill
          .getParentVO()).getPkdelivorg(), "DM018");

      String DM018 = delivOrgParaVO.getAttributeValue("DM018").toString();

      boolean bNeedTuneWriteBackItems = false;// 回写日计划的数量，根据参数 DM018
      // 和发运出库顺序的值，进行改动
      // DM018: 发运单手工关闭时是否按执行数释放回写数量
      if (DM018.equals("Y")
          && delivOrgParaVO.getAttributeValue("idelivsequence").toString()
              .equals("0")) {// 串行
        bNeedTuneWriteBackItems = true;
      }

      // 释放回写数量
      if (isEnd && bNeedTuneWriteBackItems) {// 串行 && DM018 的值为 “是” && 关闭操作
        for (int i = 0; i < items.length; i++) {

          // DM016 和 DM018 都只对来源于销售的发运单的可用量产生影响
          if (!items[i].getVbilltype().equals("30")) {
            items[i].setNfeedbacknum(items[i].getDinvnum());
            continue;
          }

          // 更新发运单回写上游数量＝累计出库数量
          // 计算回写差值：累计出库数量－原发运单回写上游数量
          // 传回写上游单据字段累计发运单数量＝回写差值
          items[i].setNfeedbacknum(items[i].getDoutnum());

          if (writeBackItems != null) {
            UFDouble invNum = items[i].getDinvnum();

            writeBackItems[i].setAttributeValue("ndelivernum", (StringTools
                .getUFDoubleFromObj(items[i].getDoutnum())).sub(invNum));

            writeBackItems[i].setAttributeValue("ddelivernewnum", items[i]
                .getDoutnum());
            writeBackItems[i].setAttributeValue("ddeliveroldnum", invNum);
          }
        }
      }
      else if (isOpen && bNeedTuneWriteBackItems) {// 串行 && DM018 的值为 “是” &&
        // 打开操作
        for (int i = 0; i < items.length; i++) {

          // 更新发运单回写上游数量＝发运单数量
          // 计算回写差值：发运单数量－原发运单回写上游数量
          // 传回写上游单据字段累计发运单数量＝回写差值
          items[i].setNfeedbacknum(items[i].getDinvnum());

          // DM016 和 DM018 都只对来源于销售的发运单的可用量产生影响
          if (!items[i].getVbilltype().equals("30"))
            continue;

          if (writeBackItems != null) {
            UFDouble invNum = items[i].getDinvnum();

            // 由于此前关闭发运单时，改写了上游的 发运数量， 故此时需要补偿性地将发运数量改写回来
            writeBackItems[i].setAttributeValue("ndelivernum", invNum
                .sub(StringTools.getUFDoubleFromObj(items[i].getDoutnum())));
            writeBackItems[i].setAttributeValue("ddelivernewnum", invNum);
            writeBackItems[i].setAttributeValue("ddeliveroldnum", items[i]
                .getDoutnum());
          }
        }
      }
      else {// 并行 || (串行 && DM018 的值为 “否”) || (!打开操作 && !关闭操作)
        // 更新发运单回写上游数量＝发运单数量
        // 计算回写差值：发运单数量－原发运单写上游数量
        // 回写上游单据累计发运单数量＝回写差值
        for (int i = 0; i < items.length; i++) {
          items[i].setNfeedbacknum(items[i].getDinvnum());
        }
      }

      // 不是（关闭操作or打开）
      if (!isEnd && !isOpen) {
        return updateNotOpenOrClose(delivbill, writeBackItems, isModifyATP,
            delivOrgParaVO.getAttributeValue("idelivsequence").toString()
                .equals("0"), clientLink);
      }

      // 是关闭操作or打开
      DLATP dlATP = new DLATP();

      DelivbillHDMO dmo = new DelivbillHDMO();
      isMustSign = dmo.isMustSign(header.getPkdelivmode().trim());

      for (int i = 0; i < items.length; i++) {
        if (items[i] != null) {
          if (items[i].getDsignnum() == null
              || items[i].getDsignnum().doubleValue() <= 0) {
            // 对于没有签收的行
            isSigned = false;
            break;
          }
        }
      }

      if (isEnd && dmo.isOutBillExist(header)) {
        throw new BusinessException(NCLangResOnserver.getInstance().getStrByID(
            "40140408", "UPP40140408-000120")/* @res "存在自由状态的出库单，不能关闭!" */);
      }

      // 发运单行出库关闭，不需要检查是否已经签收
      // 发运单(整单)出库关闭，需要检查是否已经签收
      if (isMustSign && !isSigned && !isRowEndOrOpenOP.booleanValue()) {
        throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance()
            .getStrByID("40140408", "UPP40140408-000121")/*
                                                           * @res
                                                           * "有发运单表体行仍未签收，不能关闭!"
                                                           */);
      }

      // 发运参数“DM018发运单关闭时是否按执行数回写数量”为“Y”且串行时,
      // 在发运安排中对其中一行“行关闭”，然后再进行“整单关闭”，
      // 则该行发运单回写日计划的已发运数量差值应该为 0
      if (bNeedTuneWriteBackItems) {
        for (int k = 0; k < items.length; k++) {
          if (StringTools.getSimilarBoolean(items[k].getBcloseout_old())) {
            // ndelivernum(发运累计数量值)
            writeBackItems[k].setAttributeValue("ndelivernum",
                new UFDouble(0.0));

            UFDouble invNum = items[k].getDinvnum();
            writeBackItems[k].setAttributeValue("ddelivernewnum", invNum);
            writeBackItems[k].setAttributeValue("ddeliveroldnum", invNum);
          }
        }
      }

      // 可用量接口

      if (!isModifyATP
          || !delivOrgParaVO.getAttributeValue("idelivsequence").toString()
              .equals("0")) {
        // updateGeneral(DelivbillHVO delivbillH, DMDataVO[] writeBackItems,
        // boolean isForOut, ClientLink clientLink)
        resultlist = updateGeneral(delivbill, writeBackItems, false, clientLink);
      }
      else {// 只有串行的情况下才需要修改可用量
        if (isOpen) {
          if (DM018.equals("Y")) {// 关闭发运单,是否释放上游数量
            simulateModifyFreeDelivBill(delivbill);
          }

          resultlist = updateGeneral(delivbill, writeBackItems, false,
              clientLink);

          //
          Vector vNonSoRows = new Vector();// 来源订单不是销售订单
          Vector vSoRows = new Vector();// 来源订单是销售订单
          for (int k = 0; k < items.length; k++) {
            if (!items[k].getVbilltype().equals("30"))
              vNonSoRows.add(items[k]);
            else
              vSoRows.add(items[k]);
          }

          DelivbillHItemVO[] tmpItems = (DelivbillHItemVO[]) vNonSoRows
              .toArray(new DelivbillHItemVO[vNonSoRows.size()]);
          delivbill.setChildrenVO(tmpItems);
          dlATP.modifyATPWhenOpenBill(delivbill);// 该方法不查询数据库
          //

          // 打开时，使用 vo中nfeedbacknum - vo中下游执行数量
          if (!DM018.equals("Y")) {
            tmpItems = (DelivbillHItemVO[]) vSoRows
                .toArray(new DelivbillHItemVO[vSoRows.size()]);
            delivbill.setChildrenVO(tmpItems);
            dlATP.modifyATPWhenOpenBill(delivbill);// 该方法不查询数据库
          }
          dlATP.checkAtpInstantly(delivbill, null);
          delivbill.setChildrenVO(items);// 恢复该发运单完整的表体集合
        }
        else {
          Vector v = new Vector();
          for (int k = 0; k < items.length; k++) {
            // 是否已出库关闭标志备份值--在发运单整单关闭时使用到
            // 发运单行出库状态已经关闭的行不会再影响可用量
            if (!StringTools.getSimilarBoolean(items[k].getBcloseout_old())) {
              v.add(items[k]);
            }
          }

          DelivbillHItemVO[] tmpItems = (DelivbillHItemVO[]) v
              .toArray(new DelivbillHItemVO[v.size()]);

          // 模仿自由状态的单据修改保存
          if (DM018.equals("Y")) {// 关闭发运单,是否释放上游数量
            delivbill.setChildrenVO(tmpItems);

            simulateModifyFreeDelivBill(delivbill);

            // 恢复该发运单完整的表体集合
            delivbill.setChildrenVO(items);
          }

          // 修改可用量的时候，需要查询发运单表体行的 nfeedbacknum 字段的值
          resultlist = updateGeneral(delivbill, writeBackItems, false,
              clientLink);

          delivbill.setChildrenVO(tmpItems);
          // 对于此前已经 行出库关闭 的行，不能再有 释放可用量 的操作
          // 关闭时，使用 vo中nfeedbacknum - vo中下游执行数量
          dlATP.modifyATPWhenCloseBill(delivbill); // 该方法不查询数据库

          dlATP.checkAtpInstantly(delivbill, null);
          // 恢复该发运单完整的表体集合
          // maybe redundant, but it makes safer all time
          delivbill.setChildrenVO(items);
        }
      }
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }

    return resultlist;
  }

  /**
   * 更新发运单。 这些操作不是关闭发运单、打开发运单、发运单行关闭、发运单行打开等操作。
   * 
   * @param delivbill
   * @param writeBackItems
   * @param isModifyATP
   * @param isSerialDeliv
   * @param clientLink
   * @return
   * @throws BusinessException
   */
  private ArrayList updateNotOpenOrClose(DelivbillHVO delivbill,
      DMDataVO[] writeBackItems, boolean isModifyATP, boolean isSerialDeliv, // 是否串行
      ClientLink clientLink) throws Exception {
    DLATP dmatp = new DLATP();
    if (isModifyATP && isSerialDeliv) {// 可用量接口
      dmatp.modifyATP(delivbill);
    }
    return updateGeneral(delivbill, writeBackItems, false, clientLink);
  }

  /**
   * //发运日计划关闭、发运单行出库关闭，分串行、并行两种模式： //? 串行模式：发运日计划关闭，按下游发运单行数量改写日计划【回写上游数量】为A， //
   * 同时调用回写上游规则，改写上游销售订单、调拨订单或采购订单的已发运数量为A； //
   * 发运单行出库关闭，按下游出库单行实发数量改写发运单【回写上游数量】为A， // 同时调用回写上游规则，改写上游发运日计划的已发运数量为A。 //?
   * 并行模式：由于发运单不影响ATP, 发运日计划关闭， // 无论有无发运单，都按下游出库单行签字数量改写发运日计划【回写上游数量】为A， //
   * 同时调用回写上游规则，改写上游销售订单、调拨订单或采购订单的已发运数量为A； // 发运单行出库关闭，由于下游无出库动作，没有回写影响。
   * 
   * @param delivbill
   * @param writeBackItems
   * @param isEnd
   *          关闭操作
   * @param clientLink
   * @return
   * @throws BusinessException
   */
  private ArrayList updateForWriteBackOutNum(DelivbillHVO delivbill,
      DMDataVO[] writeBackItems, boolean isEnd, ClientLink clientLink)
      throws BusinessException {

    if (delivbill == null)
      return null;

    DelivbillHItemVO[] items = (DelivbillHItemVO[]) delivbill.getChildrenVO();
    DelivbillHHeaderVO header = (DelivbillHHeaderVO) delivbill.getParentVO();

    ArrayList resultlist = null;

    boolean isSigned = true;
    boolean isMustSign = false;
    try {
      // DM018：发运单关闭是否释放回写数量参数
      DMDataVO delivOrgParaVO = getDelivOrgPara(((DelivbillHHeaderVO) delivbill
          .getParentVO()).getPkdelivorg(), "DM018");

      String DM018 = delivOrgParaVO.getAttributeValue("DM018").toString();

      if (!isEnd) {// 不是（关闭）
        resultlist = updateGeneralForWriteBackOutNum(delivbill, writeBackItems,
            false, false, clientLink);
      }
      else { // 是关闭操作
        DelivbillHDMO dmo = new DelivbillHDMO();
        isMustSign = dmo.isMustSign(header.getPkdelivmode().trim());

        for (int i = 0; i < items.length; i++) {
          if (items[i] != null) {
            if (items[i].getDsignnum() == null
                || items[i].getDsignnum().doubleValue() <= 0) {
              // 对于没有签收的行
              isSigned = false;
              break;
            }
          }
        }
        if (dmo.isOutBillExist(header)) {
          for (int i = 0; i < items.length; i++) {
            if (items[i] != null) {
              Integer rowStatus = (Integer) items[i].getIrowstatus();
              UFBoolean ufb = (UFBoolean) items[i].getBcloseout();
              ufb = ufb == null ? UFBoolean.FALSE : ufb;

              if (rowStatus.intValue() == DelivBillStatus.End) {
                String message = NCLangResOnserver.getInstance().getStrByID(
                    "40140408", "UPP40140408-000200");
                /* @res "发运单已经关闭，不能修改" */
                throw new BusinessException(message);
              }
              else if (rowStatus.intValue() == DelivBillStatus.Audit
                  && ufb.booleanValue()) {

                String message = NCLangResOnserver.getInstance().getStrByID(
                    "40140408", "UPP40140408-000201");
                /* @res "发运单已经行出库关闭，不能修改" */
                throw new BusinessException(message);
              }
            }
          }
          throw new BusinessException(NCLangResOnserver.getInstance()
              .getStrByID("40140408", "UPP40140408-000195")/*
                                                             * @res
                                                             * "存在自由状态的出库单，发运单不能关闭!请检查发运单状态!"
                                                             */);
        }

        // 发运单行出库关闭，不检查是否已经签收
        // 发运单(整单)出库关闭，检查是否已经签收
        if (isMustSign && !isSigned) {
          throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance()
              .getStrByID("40140408", "UPP40140408-000121")/*
                                                             * @res
                                                             * "有发运单表体行仍未签收，不能关闭!"
                                                             */);
        }

        // 模仿自由状态的单据修改保存
        if (DM018.equals("Y")) {
          for (int i = 0; i < items.length; i++) {
            if (items[i].getVbilltype().equals("30")) {
              writeBackItems[i].setAttributeValue("ndelivernum", items[i]
                  .getDoutnumMargin()); // 是否应该取相反数？？？？
              items[i].setNfeedbacknum(items[i].getDoutnum());// 维护回写上游数量nfeedbacknum
            }
            else {
              writeBackItems[i].setAttributeValue("ndelivernum", new UFDouble(
                  0.0));
              items[i].setNfeedbacknum(items[i].getDinvnum());
            }
          }

          simulateModifyFreeDelivBill(delivbill);

          // 修改可用量的时候，需要查询发运单表体行的 nfeedbacknum 字段的值
          resultlist = updateGeneralForWriteBackOutNum(delivbill,
              writeBackItems, false, true, clientLink);

          DLATP dmatp = new DLATP();
          // 对于此前已经 行出库关闭 的行，不能再有 释放可用量 的操作
          dmatp.modifyATPWhenCloseBill(delivbill);
          // v5增加：可用量即时校验
          dmatp.checkAtpInstantly(delivbill, null);
        }
        else {
          resultlist = updateGeneralForWriteBackOutNum(delivbill,
              writeBackItems, false, false, clientLink);
        }
      }

    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }

    return resultlist;
  }

  /**
   * 用VO对象的属性值更新数据库。 创建日期：(2002-6-3)
   * 
   * @param delivbillH
   *          nc.vo.dm.dm104.DelivbillHVO
   * @exception BusinessException
   *              异常说明。
   */
  public ArrayList updateDelivAndPack(DelivbillHVO delivbillH,
      DMDataVO[] writeBackItems, DMDataVO[] dmdPackItems, ClientLink clientLink)
      throws BusinessException {
	  ArrayList resultlist;
      try {
      // resultlist = updateForSave(delivbillH, writeBackItems, clientLink);
        IScm srv = (IScm) NCLocator.getInstance().lookup(IScm.class.getName());    
        srv.checkDefDataType(delivbillH);
   
      boolean isModifyATP = true;
      if(writeBackItems.length != 0 
      		&& writeBackItems[0].getAttributeValue("vbilltype") != null
    			&& "21".equals(writeBackItems[0].getAttributeValue("vbilltype").toString()))
      {
    	  isModifyATP = false;
    	
      }
      resultlist = updateDelivbill(delivbillH, writeBackItems, isModifyATP, clientLink);

      // 删除相应运费单
      deleteTransFeeBillVO(delivbillH);

      // 保存包装单
      saveDelivPackNum(dmdPackItems);
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    return resultlist;
  }

  /**
   * 创建日期：2004-5-25 20:30 作者：zxping 参数：htDelivbillBodyPks Hashtable 发运单行pks
   * 说明：确保途损数量在正确范围之内（较验）
   * 
   * @return String 如果 .length()>0 ， 则表明存在不合法的回写途损数量 否则， 合法。
   */
  private String verifyWayLossNum(Hashtable htDelivbillBodyPks)
      throws Exception {
    if (htDelivbillBodyPks == null || htDelivbillBodyPks.size() == 0) {
      return null;
    }

    StringBuffer sb1 = new StringBuffer();
    Iterator iterator = htDelivbillBodyPks.values().iterator();
    while (iterator.hasNext()) {
      if (sb1.length() > 0) {
        sb1.append(",'" + iterator.next().toString() + "'");
      }
      else {
        sb1.append("'" + iterator.next().toString() + "'");
      }
    }

    StringBuffer sb2 = new StringBuffer();
    sb2
        .append(
            "select pk_delivbill_b, irownumber, isnull(doutnum,0)-isnull(dsignnum,0)-isnull(dcancelnum,0) as dmaxwaylossnum from dm_delivbill_b ")
        .append("where pk_delivbill_b in (")
        .append(sb1.toString())
        .append(
            ") and isnull(doutnum,0)-isnull(dsignnum,0)-isnull(dcancelnum,0)-isnull(dwaylossnum,0)<0 ");

    DMDataVO[] dmdatavo;
    try {
      dmdatavo = super.query(sb2);
    }
    catch (Exception e) {
      throw e;
    }

    StringBuffer sb3 = new StringBuffer();
    StringBuffer sb4 = new StringBuffer();
    if (dmdatavo != null && dmdatavo.length > 0) {

      for (int i = 0; i < dmdatavo.length; i++) {
        sb3.append("[" + dmdatavo[i].getAttributeValue("irownumber").toString()
            + "]");
        sb4.append("["
            + dmdatavo[i].getAttributeValue("dmaxwaylossnum").toString() + "]");
      }
      String[] value = new String[] {
          sb3.toString(), sb4.toString()
      };// ,null,value
      return nc.bs.ml.NCLangResOnserver.getInstance().getStrByID("40140408",
          "UPP40140408-000130", null, value)/* @res "行号：{0} 最大途损数量分别为：{1}" */;
    }

    return null;
  }

  /**
   * 向数据库中插入一个VO对象。 创建日期：(2002-6-3)
   * 
   * @param delivbillH
   *          nc.vo.dm.dm104.DelivbillHVO
   * @return java.lang.String 所插入VO对象的主键字符串。
   * @exception BusinessException
   *              异常说明。
   */
  public ArrayList insertDelivbills(DelivbillHVO[] delivbillHs,
      DMDataVO[] writeBackItems, ClientLink clientLink)
      throws BusinessException {
    String sLockPk[] = null;
    String sUserID = null;

    try {
      IScm srv = (IScm) NCLocator.getInstance().lookup(IScm.class.getName()); 
      for(int i = 0; i<delivbillHs.length; i++)
      srv.checkDefDataType(delivbillHs[i]);
      // insert之后时间戳]
      DelivbillHVO delivbillH = null;
      ArrayList keylist = null;
      ArrayList alKeylists = new ArrayList();
      DelivbillHDMO dmo = new DelivbillHDMO();
      nc.bs.dm.pub.toic.DLATP atp = null;
      for (int i = 0; i < delivbillHs.length; i++) {
        delivbillH = delivbillHs[i];
        // 加锁
        sLockPk = dmo.getLockPKsArray(delivbillH, "pk_delivbill_h",
            "pk_delivbill_b", "pk_delivbill_h", new String[] {
              "pkdayplan"
            }, new String[0]);
        sUserID = clientLink.getUser();

        lockPKs(sLockPk, sUserID);

        //
        if (dmo.isBillCodeDuplicated(delivbillH)) {
          throw new BusinessException(nc.bs.ml.NCLangResOnserver.getInstance()
              .getStrByID("40140408", "UPP40140408-000115")/* @res "单据号重复！" */);
        }
        //

        // 新增保存前的上游单据时间戳校验
        checkSourceTsForNewAdd("vdayplancode", "pkdayplan", "sourcebillts",
            new String[] {
              "dm_delivdaypl"
            }, new String[] {
              "pk_delivdaypl"
            }, new String[] {
              "ts"
            }, delivbillH.getChildrenVO());

        DelivbillHItemVO[] allBakItems = (DelivbillHItemVO[]) delivbillH
                                          .getChildrenVO();

        for (int j = 0; j < allBakItems.length; j++) 
        {
        	allBakItems[j].setNfeedbacknum(allBakItems[j].getDinvnum());
        }
        
        // 可用量接口
        if (delivbillH.getChildrenVO().length > 0) {
        	//采购订单生成的发运单不需要修改可用量
        	if(allBakItems[0].getVbilltype() != null
        			&& !"21".equals(allBakItems[0].getVbilltype()))
        	{
        		atp = new nc.bs.dm.pub.toic.DLATP();
        		atp.modifyATP(delivbillH);
        	}
        }

        keylist = dmo.insert(delivbillH, clientLink);

        // 进行按钮注册
        delivbillH.getParentVO().setAttributeValue("pk_delivbill_h",
            keylist.get(0).toString());
        signButtonClickTime(RecordType.SAVESEND, delivbillH, false);

        alKeylists.add(keylist);
      }
      // 回写发运日计划
      if (writeBackItems != null) {
        nc.impl.dm.dm102.DeliverydailyplanImpl remote = new nc.impl.dm.dm102.DeliverydailyplanImpl();
        remote.setSendNum(writeBackItems);
      }

      // v5增加：可用量即时校验
      if (atp != null) {
        for (int i = 0; i < delivbillHs.length; i++) {
          atp.checkAtpInstantly(delivbillHs[i], null);
        }
      }
      return alKeylists;
    }
    catch (Exception e) {
      reportException(e);
      if (e instanceof BusinessException)
        throw (BusinessException) e;
      else
        throw new BusinessException(e);
    }
    finally {
      // 解锁
      unLockPKs(sLockPk, sUserID);
    }
  }

  private void checkDelivbillTs(String billid, String ts)
      throws BusinessException {
    StringBuffer sql = new StringBuffer();
    sql.append(" select vdelivbillcode from dm_delivbill_h ");
    sql.append(" where pk_delivbill_h='");
    sql.append(billid);
    sql.append("' and ts <>'");
    sql.append(ts);
    sql.append("'");
    DmImpl bo = new DmImpl();
    DMDataVO[] data = bo.queryStringBuffer(sql);
    if (data.length > 0) {
      StringBuffer billcode = new StringBuffer();
      for (int i = 0; i < data.length; i++) {
        billcode.append(data[i].getAttributeValue("vdelivbillcode"));
        billcode.append(",");
      }
      billcode.deleteCharAt(billcode.length() - 1);
      String[] args = new String[1];
      args[0] = billcode.toString();
      String message = nc.bs.ml.NCLangResOnserver.getInstance().getStrByID(
          "40140408", "UPP40140408-000199", null, args);
      /* @res "发运单{0}已经被修改，请重新查询" */
      BusinessException ex = new BusinessException(message);
      throw ex;
    }
  }

}